<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/facebook/jscodeshift#readme">jscodeshift (v0.3.30)</a>
</h1>
<h4>A toolkit for JavaScript codemods</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift">module jscodeshift</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jscodeshift">
            function <span class="apidocSignatureSpan"></span>jscodeshift
            <span class="apidocSignatureSpan">(source, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.anyTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>anyTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.arrayExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>arrayExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.arrayPattern">
            function <span class="apidocSignatureSpan">jscodeshift.</span>arrayPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.arrayStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>arrayStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.arrayTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>arrayTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.arrowFunctionExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>arrowFunctionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.arrowFunctionStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>arrowFunctionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.assignmentExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>assignmentExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.assignmentPattern">
            function <span class="apidocSignatureSpan">jscodeshift.</span>assignmentPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.assignmentStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>assignmentStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.awaitExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>awaitExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.awaitStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>awaitStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.binaryExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>binaryExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.binaryStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>binaryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.bindExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>bindExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.bindStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>bindStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.block">
            function <span class="apidocSignatureSpan">jscodeshift.</span>block
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.blockStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>blockStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.booleanLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.</span>booleanLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.booleanLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>booleanLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.booleanLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>booleanLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.booleanTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>booleanTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.breakStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>breakStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.callExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>callExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.callStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>callStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.catchClause">
            function <span class="apidocSignatureSpan">jscodeshift.</span>catchClause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.classBody">
            function <span class="apidocSignatureSpan">jscodeshift.</span>classBody
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.classDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>classDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.classExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>classExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.classImplements">
            function <span class="apidocSignatureSpan">jscodeshift.</span>classImplements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.classMethod">
            function <span class="apidocSignatureSpan">jscodeshift.</span>classMethod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.classProperty">
            function <span class="apidocSignatureSpan">jscodeshift.</span>classProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.classPropertyDefinition">
            function <span class="apidocSignatureSpan">jscodeshift.</span>classPropertyDefinition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.classStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>classStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.commentBlock">
            function <span class="apidocSignatureSpan">jscodeshift.</span>commentBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.commentLine">
            function <span class="apidocSignatureSpan">jscodeshift.</span>commentLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.comprehensionBlock">
            function <span class="apidocSignatureSpan">jscodeshift.</span>comprehensionBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.comprehensionExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>comprehensionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.comprehensionStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>comprehensionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.conditionalExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>conditionalExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.conditionalStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>conditionalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.continueStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>continueStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.debuggerStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>debuggerStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.declareClass">
            function <span class="apidocSignatureSpan">jscodeshift.</span>declareClass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.declareExportAllDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>declareExportAllDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.declareExportDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>declareExportDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.declareFunction">
            function <span class="apidocSignatureSpan">jscodeshift.</span>declareFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.declareInterface">
            function <span class="apidocSignatureSpan">jscodeshift.</span>declareInterface
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.declareModule">
            function <span class="apidocSignatureSpan">jscodeshift.</span>declareModule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.declareModuleExports">
            function <span class="apidocSignatureSpan">jscodeshift.</span>declareModuleExports
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.declareTypeAlias">
            function <span class="apidocSignatureSpan">jscodeshift.</span>declareTypeAlias
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.declareVariable">
            function <span class="apidocSignatureSpan">jscodeshift.</span>declareVariable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.decorator">
            function <span class="apidocSignatureSpan">jscodeshift.</span>decorator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.directive">
            function <span class="apidocSignatureSpan">jscodeshift.</span>directive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.directiveLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.</span>directiveLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.directiveLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>directiveLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.doExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>doExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.doStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>doStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.doWhileStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>doWhileStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.emptyStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>emptyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.emptyTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>emptyTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.existentialTypeParam">
            function <span class="apidocSignatureSpan">jscodeshift.</span>existentialTypeParam
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.existsTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>existsTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.exportAllDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>exportAllDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.exportBatchSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.</span>exportBatchSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.exportDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>exportDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.exportDefaultDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>exportDefaultDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.exportDefaultSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.</span>exportDefaultSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.exportNamedDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>exportNamedDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.exportNamespaceSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.</span>exportNamespaceSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.exportSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.</span>exportSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.expressionStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>expressionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.file">
            function <span class="apidocSignatureSpan">jscodeshift.</span>file
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.forAwaitStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>forAwaitStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.forInStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>forInStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.forOfStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>forOfStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.forStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>forStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.functionDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>functionDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.functionExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>functionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.functionStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>functionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.functionTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>functionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.functionTypeParam">
            function <span class="apidocSignatureSpan">jscodeshift.</span>functionTypeParam
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.generatorExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>generatorExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.generatorStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>generatorStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.genericTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>genericTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.graphExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>graphExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.graphIndexExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>graphIndexExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.graphIndexStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>graphIndexStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.graphStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>graphStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.identifier">
            function <span class="apidocSignatureSpan">jscodeshift.</span>identifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.identifierStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>identifierStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.ifStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>ifStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.import">
            function <span class="apidocSignatureSpan">jscodeshift.</span>import
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.importDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>importDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.importDefaultSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.</span>importDefaultSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.importNamespaceSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.</span>importNamespaceSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.importSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.</span>importSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.importStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>importStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.interfaceDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>interfaceDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.interfaceExtends">
            function <span class="apidocSignatureSpan">jscodeshift.</span>interfaceExtends
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.intersectionTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>intersectionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxAttribute">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxClosingElement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxClosingElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxElement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxElementStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxElementStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxEmptyExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxEmptyExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxEmptyStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxEmptyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxExpressionContainer">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxExpressionContainer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxExpressionContainerStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxExpressionContainerStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxIdentifier">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxIdentifierStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxIdentifierStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxMemberExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxMemberExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxMemberStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxMemberStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxNamespacedName">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxNamespacedName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxOpeningElement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxOpeningElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxSpreadAttribute">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxSpreadAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxText">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.jsxTextStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>jsxTextStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.labeledStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>labeledStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.letExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>letExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.letStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>letStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.line">
            function <span class="apidocSignatureSpan">jscodeshift.</span>line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.literal">
            function <span class="apidocSignatureSpan">jscodeshift.</span>literal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.literalStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>literalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.logicalExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>logicalExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.logicalStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>logicalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.match">
            function <span class="apidocSignatureSpan">jscodeshift.</span>match
            <span class="apidocSignatureSpan">(path, filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.memberExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>memberExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.memberStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>memberStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.memberTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>memberTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.metaProperty">
            function <span class="apidocSignatureSpan">jscodeshift.</span>metaProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.metaPropertyStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>metaPropertyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.methodDefinition">
            function <span class="apidocSignatureSpan">jscodeshift.</span>methodDefinition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.mixedTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>mixedTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.newExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>newExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.newStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>newStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.noop">
            function <span class="apidocSignatureSpan">jscodeshift.</span>noop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.nullLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.</span>nullLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.nullLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>nullLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.nullLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>nullLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.nullTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>nullTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.nullableTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>nullableTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.numberLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>numberLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.numberTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>numberTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.numericLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.</span>numericLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.numericLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>numericLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.numericLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>numericLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.objectExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>objectExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.objectMethod">
            function <span class="apidocSignatureSpan">jscodeshift.</span>objectMethod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.objectPattern">
            function <span class="apidocSignatureSpan">jscodeshift.</span>objectPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.objectProperty">
            function <span class="apidocSignatureSpan">jscodeshift.</span>objectProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.objectStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>objectStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.objectTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>objectTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.objectTypeCallProperty">
            function <span class="apidocSignatureSpan">jscodeshift.</span>objectTypeCallProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.objectTypeIndexer">
            function <span class="apidocSignatureSpan">jscodeshift.</span>objectTypeIndexer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.objectTypeProperty">
            function <span class="apidocSignatureSpan">jscodeshift.</span>objectTypeProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.parenthesizedExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>parenthesizedExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.parenthesizedStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>parenthesizedStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.position">
            function <span class="apidocSignatureSpan">jscodeshift.</span>position
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.program">
            function <span class="apidocSignatureSpan">jscodeshift.</span>program
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.property">
            function <span class="apidocSignatureSpan">jscodeshift.</span>property
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.propertyPattern">
            function <span class="apidocSignatureSpan">jscodeshift.</span>propertyPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.qualifiedTypeIdentifier">
            function <span class="apidocSignatureSpan">jscodeshift.</span>qualifiedTypeIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.regExpLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.</span>regExpLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.regExpLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>regExpLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.registerMethods">
            function <span class="apidocSignatureSpan">jscodeshift.</span>registerMethods
            <span class="apidocSignatureSpan">(methods, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.restElement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>restElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.restProperty">
            function <span class="apidocSignatureSpan">jscodeshift.</span>restProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.returnStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>returnStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.sequenceExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>sequenceExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.sequenceStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>sequenceStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.sourceLocation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>sourceLocation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.spreadElement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>spreadElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.spreadElementPattern">
            function <span class="apidocSignatureSpan">jscodeshift.</span>spreadElementPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.spreadProperty">
            function <span class="apidocSignatureSpan">jscodeshift.</span>spreadProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.spreadPropertyPattern">
            function <span class="apidocSignatureSpan">jscodeshift.</span>spreadPropertyPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.stringLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.</span>stringLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.stringLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>stringLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.stringLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>stringLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.stringTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>stringTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.super">
            function <span class="apidocSignatureSpan">jscodeshift.</span>super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.superStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>superStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.switchCase">
            function <span class="apidocSignatureSpan">jscodeshift.</span>switchCase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.switchStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>switchStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.taggedTemplateExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>taggedTemplateExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.taggedTemplateStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>taggedTemplateStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.templateElement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>templateElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.templateLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.</span>templateLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.templateLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>templateLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.thisExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>thisExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.thisStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>thisStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.thisTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>thisTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.throwStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>throwStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.tryStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>tryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.tupleTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>tupleTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.typeAlias">
            function <span class="apidocSignatureSpan">jscodeshift.</span>typeAlias
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.typeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>typeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.typeCastExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>typeCastExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.typeCastStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>typeCastStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.typeParameter">
            function <span class="apidocSignatureSpan">jscodeshift.</span>typeParameter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.typeParameterDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>typeParameterDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.typeParameterInstantiation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>typeParameterInstantiation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.typeofTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>typeofTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath">
            function <span class="apidocSignatureSpan">jscodeshift.</span>types.NodePath
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path">
            function <span class="apidocSignatureSpan">jscodeshift.</span>types.Path
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor">
            function <span class="apidocSignatureSpan">jscodeshift.</span>types.PathVisitor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Type">
            function <span class="apidocSignatureSpan">jscodeshift.</span>types.Type
            <span class="apidocSignatureSpan">(check, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.astNodesAreEquivalent">
            function <span class="apidocSignatureSpan">jscodeshift.</span>types.astNodesAreEquivalent
            <span class="apidocSignatureSpan">(a, b, problemPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.unaryExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>unaryExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.unaryStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>unaryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.unionTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>unionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.updateExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>updateExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.updateStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>updateStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.use">
            function <span class="apidocSignatureSpan">jscodeshift.</span>use
            <span class="apidocSignatureSpan">(plugin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.variableDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.</span>variableDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.variableDeclarator">
            function <span class="apidocSignatureSpan">jscodeshift.</span>variableDeclarator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.voidTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.</span>voidTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.whileStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>whileStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.withParser">
            function <span class="apidocSignatureSpan">jscodeshift.</span>withParser
            <span class="apidocSignatureSpan">(parser)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.withStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>withStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.yieldExpression">
            function <span class="apidocSignatureSpan">jscodeshift.</span>yieldExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.yieldStatement">
            function <span class="apidocSignatureSpan">jscodeshift.</span>yieldStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>AnyTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ArrayExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ArrayPattern</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ArrayTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ArrowFunctionExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>AssignmentExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>AssignmentPattern</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>AwaitExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>BinaryExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>BindExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Block</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>BlockStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>BooleanLiteral</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>BooleanLiteralTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>BooleanTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>BreakStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>CallExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>CatchClause</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ClassBody</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ClassDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ClassExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ClassImplements</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ClassMethod</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ClassProperty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ClassPropertyDefinition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Comment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>CommentBlock</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>CommentLine</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ComprehensionBlock</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ComprehensionExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ConditionalExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ContinueStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DebuggerStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Declaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DeclareClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DeclareExportAllDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DeclareExportDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DeclareFunction</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DeclareInterface</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DeclareModule</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DeclareModuleExports</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DeclareTypeAlias</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DeclareVariable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Decorator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Directive</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DirectiveLiteral</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DoExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>DoWhileStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>EmptyStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>EmptyTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ExistentialTypeParam</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ExistsTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ExportAllDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ExportBatchSpecifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ExportDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ExportDefaultDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ExportDefaultSpecifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ExportNamedDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ExportNamespaceSpecifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ExportSpecifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Expression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ExpressionStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>File</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ForAwaitStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ForInStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ForOfStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ForStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Function</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>FunctionDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>FunctionExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>FunctionTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>FunctionTypeParam</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>GeneratorExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>GenericTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>GraphExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>GraphIndexExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Identifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>IfStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Import</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ImportDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ImportDefaultSpecifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ImportNamespaceSpecifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ImportSpecifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>InterfaceDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>InterfaceExtends</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>IntersectionTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>JSXAttribute</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>JSXClosingElement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>JSXElement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>JSXEmptyExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>JSXExpressionContainer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>JSXIdentifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>JSXMemberExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>JSXNamespacedName</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>JSXOpeningElement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>JSXSpreadAttribute</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>JSXText</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>LabeledStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>LetExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>LetStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Line</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Literal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>LogicalExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>MemberExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>MemberTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>MetaProperty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>MethodDefinition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>MixedTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ModuleSpecifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>NewExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Node</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Noop</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>NullLiteral</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>NullLiteralTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>NullTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>NullableTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>NumberLiteralTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>NumberTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>NumericLiteral</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>NumericLiteralTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ObjectExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ObjectMethod</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ObjectPattern</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ObjectProperty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ObjectTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ObjectTypeCallProperty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ObjectTypeIndexer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ObjectTypeProperty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ParenthesizedExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Pattern</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Position</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Printable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Program</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Property</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>PropertyPattern</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>QualifiedTypeIdentifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>RegExpLiteral</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>RestElement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>RestProperty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ReturnStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>SequenceExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>SourceLocation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Specifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>SpreadElement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>SpreadElementPattern</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>SpreadProperty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>SpreadPropertyPattern</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Statement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>StringLiteral</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>StringLiteralTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>StringTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Super</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>SwitchCase</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>SwitchStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TaggedTemplateExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TemplateElement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TemplateLiteral</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ThisExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ThisTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>ThrowStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TryStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TupleTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>Type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TypeAlias</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TypeCastExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TypeParameter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TypeParameterDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TypeParameterInstantiation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>TypeofTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>UnaryExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>UnionTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>UpdateExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>VariableDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>VariableDeclarator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>VoidTypeAnnotation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>WhileStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>WithStatement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XML</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLAnyName</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLAttribute</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLAttributeSelector</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLCdata</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLComment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLDefaultDeclaration</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLElement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLEndTag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLEscape</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLFilterExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLFunctionQualifiedIdentifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLList</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLName</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLPointTag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLProcessingInstruction</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLQualifiedIdentifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLStartTag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>XMLText</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>YieldExpression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>babylon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>filters</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>flow</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>mappings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>template</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>testUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>types.NodePath.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>types.Path.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>types.PathVisitor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>types.Type.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.</span>types.builders</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.babylon">module jscodeshift.babylon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.babylon.parse">
            function <span class="apidocSignatureSpan">jscodeshift.babylon.</span>parse
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.flow">module jscodeshift.flow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.flow.parse">
            function <span class="apidocSignatureSpan">jscodeshift.flow.</span>parse
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.template">module jscodeshift.template</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.template.expression">
            function <span class="apidocSignatureSpan">jscodeshift.template.</span>expression
            <span class="apidocSignatureSpan">(template)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.template.statement">
            function <span class="apidocSignatureSpan">jscodeshift.template.</span>statement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.template.statements">
            function <span class="apidocSignatureSpan">jscodeshift.template.</span>statements
            <span class="apidocSignatureSpan">(template)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.testUtils">module jscodeshift.testUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.testUtils.createTempFileWith">
            function <span class="apidocSignatureSpan">jscodeshift.testUtils.</span>createTempFileWith
            <span class="apidocSignatureSpan">(content, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.testUtils.createTransformWith">
            function <span class="apidocSignatureSpan">jscodeshift.testUtils.</span>createTransformWith
            <span class="apidocSignatureSpan">(content, fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.testUtils.getFileContent">
            function <span class="apidocSignatureSpan">jscodeshift.testUtils.</span>getFileContent
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.types">module jscodeshift.types</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>NodePath
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>Path
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>PathVisitor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Type">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>Type
            <span class="apidocSignatureSpan">(check, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.astNodesAreEquivalent">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>astNodesAreEquivalent
            <span class="apidocSignatureSpan">(a, b, problemPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.defineMethod">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>defineMethod
            <span class="apidocSignatureSpan">(name, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.eachField">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>eachField
            <span class="apidocSignatureSpan">(object, callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.finalize">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>finalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.getFieldNames">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>getFieldNames
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.getFieldValue">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>getFieldValue
            <span class="apidocSignatureSpan">(object, fieldName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.getSupertypeNames">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>getSupertypeNames
            <span class="apidocSignatureSpan">(typeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.someField">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>someField
            <span class="apidocSignatureSpan">(object, callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.use">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>use
            <span class="apidocSignatureSpan">(plugin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.visit">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>visit
            <span class="apidocSignatureSpan">(node, methods)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.types.</span>builders</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.types.</span>builtInTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscodeshift.types.</span>namedTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.types.NodePath">module jscodeshift.types.NodePath</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath.NodePath">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>NodePath
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.types.NodePath.prototype">module jscodeshift.types.NodePath.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath.prototype._computeNode">
            function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>_computeNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath.prototype._computeParent">
            function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>_computeParent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath.prototype._computeScope">
            function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>_computeScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath.prototype.canBeFirstInStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>canBeFirstInStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath.prototype.firstInStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>firstInStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath.prototype.getValueProperty">
            function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>getValueProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath.prototype.needsParens">
            function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>needsParens
            <span class="apidocSignatureSpan">(assumeExpressionContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath.prototype.prune">
            function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>prune
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.NodePath.prototype.replace">
            function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>replace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.types.Path">module jscodeshift.types.Path</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.Path">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>Path
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.types.Path.prototype">module jscodeshift.types.Path.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.each">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>each
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.filter">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>filter
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.get">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>get
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.getValueProperty">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>getValueProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.insertAfter">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>insertAfter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.insertAt">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>insertAt
            <span class="apidocSignatureSpan">(index, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.insertBefore">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>insertBefore
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.map">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>map
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.pop">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.push">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>push
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.replace">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>replace
            <span class="apidocSignatureSpan">(replacement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.shift">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Path.prototype.unshift">
            function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>unshift
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.types.PathVisitor">module jscodeshift.types.PathVisitor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.PathVisitor">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>PathVisitor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.fromMethodsObject">
            function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.</span>fromMethodsObject
            <span class="apidocSignatureSpan">(methods)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.visit">
            function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.</span>visit
            <span class="apidocSignatureSpan">(node, methods)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.types.PathVisitor.prototype">module jscodeshift.types.PathVisitor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.AbortRequest">
            function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>AbortRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.abort">
            function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.acquireContext">
            function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>acquireContext
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.releaseContext">
            function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>releaseContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.reportChanged">
            function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>reportChanged
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.reset">
            function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>reset
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.visit">
            function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>visit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.visitWithoutReset">
            function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>visitWithoutReset
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.wasChangeReported">
            function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>wasChangeReported
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.types.Type">module jscodeshift.types.Type</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Type.Type">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>Type
            <span class="apidocSignatureSpan">(check, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Type.def">
            function <span class="apidocSignatureSpan">jscodeshift.types.Type.</span>def
            <span class="apidocSignatureSpan">(typeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Type.fromArray">
            function <span class="apidocSignatureSpan">jscodeshift.types.Type.</span>fromArray
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Type.fromObject">
            function <span class="apidocSignatureSpan">jscodeshift.types.Type.</span>fromObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Type.or">
            function <span class="apidocSignatureSpan">jscodeshift.types.Type.</span>or
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.types.Type.prototype">module jscodeshift.types.Type.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Type.prototype.arrayOf">
            function <span class="apidocSignatureSpan">jscodeshift.types.Type.prototype.</span>arrayOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Type.prototype.assert">
            function <span class="apidocSignatureSpan">jscodeshift.types.Type.prototype.</span>assert
            <span class="apidocSignatureSpan">(value, deep)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.Type.prototype.toString">
            function <span class="apidocSignatureSpan">jscodeshift.types.Type.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.types.astNodesAreEquivalent">module jscodeshift.types.astNodesAreEquivalent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.astNodesAreEquivalent.astNodesAreEquivalent">
            function <span class="apidocSignatureSpan">jscodeshift.types.</span>astNodesAreEquivalent
            <span class="apidocSignatureSpan">(a, b, problemPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.astNodesAreEquivalent.assert">
            function <span class="apidocSignatureSpan">jscodeshift.types.astNodesAreEquivalent.</span>assert
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscodeshift.types.builders">module jscodeshift.types.builders</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.anyTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>anyTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.arrayExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrayExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.arrayPattern">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrayPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.arrayStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrayStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.arrayTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrayTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.arrowFunctionExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrowFunctionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.arrowFunctionStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrowFunctionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.assignmentExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>assignmentExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.assignmentPattern">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>assignmentPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.assignmentStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>assignmentStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.awaitExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>awaitExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.awaitStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>awaitStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.binaryExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>binaryExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.binaryStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>binaryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.bindExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>bindExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.bindStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>bindStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.block">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>block
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.blockStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>blockStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.booleanLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>booleanLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.booleanLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>booleanLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.booleanLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>booleanLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.booleanTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>booleanTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.breakStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>breakStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.callExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>callExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.callStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>callStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.catchClause">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>catchClause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.classBody">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classBody
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.classDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.classExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.classImplements">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classImplements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.classMethod">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classMethod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.classProperty">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.classPropertyDefinition">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classPropertyDefinition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.classStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.commentBlock">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>commentBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.commentLine">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>commentLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.comprehensionBlock">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>comprehensionBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.comprehensionExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>comprehensionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.comprehensionStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>comprehensionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.conditionalExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>conditionalExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.conditionalStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>conditionalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.continueStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>continueStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.debuggerStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>debuggerStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.declareClass">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareClass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.declareExportAllDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareExportAllDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.declareExportDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareExportDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.declareFunction">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.declareInterface">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareInterface
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.declareModule">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareModule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.declareModuleExports">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareModuleExports
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.declareTypeAlias">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareTypeAlias
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.declareVariable">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareVariable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.decorator">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>decorator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.directive">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>directive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.directiveLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>directiveLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.directiveLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>directiveLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.doExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>doExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.doStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>doStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.doWhileStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>doWhileStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.emptyStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>emptyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.emptyTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>emptyTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.existentialTypeParam">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>existentialTypeParam
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.existsTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>existsTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.exportAllDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportAllDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.exportBatchSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportBatchSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.exportDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.exportDefaultDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportDefaultDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.exportDefaultSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportDefaultSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.exportNamedDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportNamedDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.exportNamespaceSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportNamespaceSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.exportSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.expressionStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>expressionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.file">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>file
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.forAwaitStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>forAwaitStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.forInStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>forInStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.forOfStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>forOfStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.forStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>forStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.functionDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>functionDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.functionExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>functionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.functionStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>functionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.functionTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>functionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.functionTypeParam">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>functionTypeParam
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.generatorExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>generatorExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.generatorStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>generatorStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.genericTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>genericTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.graphExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>graphExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.graphIndexExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>graphIndexExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.graphIndexStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>graphIndexStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.graphStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>graphStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.identifier">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>identifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.identifierStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>identifierStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.ifStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>ifStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.import">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>import
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.importDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>importDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.importDefaultSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>importDefaultSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.importNamespaceSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>importNamespaceSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.importSpecifier">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>importSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.importStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>importStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.interfaceDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>interfaceDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.interfaceExtends">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>interfaceExtends
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.intersectionTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>intersectionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxAttribute">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxClosingElement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxClosingElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxElement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxElementStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxElementStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxEmptyExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxEmptyExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxEmptyStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxEmptyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxExpressionContainer">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxExpressionContainer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxExpressionContainerStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxExpressionContainerStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxIdentifier">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxIdentifierStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxIdentifierStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxMemberExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxMemberExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxMemberStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxMemberStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxNamespacedName">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxNamespacedName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxOpeningElement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxOpeningElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxSpreadAttribute">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxSpreadAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxText">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.jsxTextStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxTextStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.labeledStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>labeledStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.letExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>letExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.letStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>letStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.line">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.literal">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>literal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.literalStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>literalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.logicalExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>logicalExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.logicalStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>logicalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.memberExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>memberExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.memberStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>memberStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.memberTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>memberTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.metaProperty">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>metaProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.metaPropertyStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>metaPropertyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.methodDefinition">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>methodDefinition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.mixedTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>mixedTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.newExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>newExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.newStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>newStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.noop">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>noop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.nullLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>nullLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.nullLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>nullLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.nullLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>nullLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.nullTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>nullTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.nullableTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>nullableTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.numberLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>numberLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.numberTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>numberTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.numericLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>numericLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.numericLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>numericLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.numericLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>numericLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.objectExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.objectMethod">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectMethod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.objectPattern">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.objectProperty">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.objectStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.objectTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.objectTypeCallProperty">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectTypeCallProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.objectTypeIndexer">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectTypeIndexer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.objectTypeProperty">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectTypeProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.parenthesizedExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>parenthesizedExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.parenthesizedStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>parenthesizedStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.position">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>position
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.program">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>program
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.property">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>property
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.propertyPattern">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>propertyPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.qualifiedTypeIdentifier">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>qualifiedTypeIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.regExpLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>regExpLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.regExpLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>regExpLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.restElement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>restElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.restProperty">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>restProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.returnStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>returnStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.sequenceExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>sequenceExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.sequenceStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>sequenceStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.sourceLocation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>sourceLocation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.spreadElement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>spreadElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.spreadElementPattern">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>spreadElementPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.spreadProperty">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>spreadProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.spreadPropertyPattern">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>spreadPropertyPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.stringLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>stringLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.stringLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>stringLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.stringLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>stringLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.stringTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>stringTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.super">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.superStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>superStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.switchCase">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>switchCase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.switchStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>switchStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.taggedTemplateExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>taggedTemplateExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.taggedTemplateStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>taggedTemplateStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.templateElement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>templateElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.templateLiteral">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>templateLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.templateLiteralStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>templateLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.thisExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>thisExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.thisStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>thisStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.thisTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>thisTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.throwStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>throwStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.tryStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>tryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.tupleTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>tupleTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.typeAlias">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeAlias
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.typeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.typeCastExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeCastExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.typeCastStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeCastStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.typeParameter">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeParameter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.typeParameterDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeParameterDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.typeParameterInstantiation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeParameterInstantiation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.typeofTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeofTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.unaryExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>unaryExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.unaryStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>unaryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.unionTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>unionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.updateExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>updateExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.updateStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>updateStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.variableDeclaration">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>variableDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.variableDeclarator">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>variableDeclarator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.voidTypeAnnotation">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>voidTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.whileStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>whileStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.withStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>withStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.yieldExpression">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>yieldExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscodeshift.types.builders.yieldStatement">
            function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>yieldStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift" id="apidoc.module.jscodeshift">module jscodeshift</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.jscodeshift" id="apidoc.element.jscodeshift.jscodeshift">
        function <span class="apidocSignatureSpan"></span>jscodeshift
        <span class="apidocSignatureSpan">(source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function core(source, options) {
  return typeof source === 'string' ?
    fromSource(source, options) :
    fromAST(source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a more detailed description can be found below.

```js
/**
 * This replaces every occurence of variable "foo".
 */
module.exports = function(fileInfo, api) {
  return api.<span class="apidocCodeKeywordSpan">jscodeshift</span>(fileInfo.source)
    .findVariableDeclarators('foo')
    .renameTo('bar')
    .toSource();
}
```

**Note:** This api is exposed for convenience, but you don't have to use it.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.anyTypeAnnotation" id="apidoc.element.jscodeshift.anyTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>anyTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anyTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.arrayExpression" id="apidoc.element.jscodeshift.arrayExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>arrayExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.arrayPattern" id="apidoc.element.jscodeshift.arrayPattern">
        function <span class="apidocSignatureSpan">jscodeshift.</span>arrayPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.arrayStatement" id="apidoc.element.jscodeshift.arrayStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>arrayStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.arrayTypeAnnotation" id="apidoc.element.jscodeshift.arrayTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>arrayTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.arrowFunctionExpression" id="apidoc.element.jscodeshift.arrowFunctionExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>arrowFunctionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrowFunctionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.arrowFunctionStatement" id="apidoc.element.jscodeshift.arrowFunctionStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>arrowFunctionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrowFunctionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.assignmentExpression" id="apidoc.element.jscodeshift.assignmentExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>assignmentExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.assignmentPattern" id="apidoc.element.jscodeshift.assignmentPattern">
        function <span class="apidocSignatureSpan">jscodeshift.</span>assignmentPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.assignmentStatement" id="apidoc.element.jscodeshift.assignmentStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>assignmentStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.awaitExpression" id="apidoc.element.jscodeshift.awaitExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>awaitExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">awaitExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.awaitStatement" id="apidoc.element.jscodeshift.awaitStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>awaitStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">awaitStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.binaryExpression" id="apidoc.element.jscodeshift.binaryExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>binaryExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binaryExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.binaryStatement" id="apidoc.element.jscodeshift.binaryStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>binaryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binaryStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.bindExpression" id="apidoc.element.jscodeshift.bindExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>bindExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.bindStatement" id="apidoc.element.jscodeshift.bindStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>bindStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.block" id="apidoc.element.jscodeshift.block">
        function <span class="apidocSignatureSpan">jscodeshift.</span>block
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.blockStatement" id="apidoc.element.jscodeshift.blockStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>blockStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blockStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.booleanLiteral" id="apidoc.element.jscodeshift.booleanLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.</span>booleanLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.booleanLiteralStatement" id="apidoc.element.jscodeshift.booleanLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>booleanLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.booleanLiteralTypeAnnotation" id="apidoc.element.jscodeshift.booleanLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>booleanLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.booleanTypeAnnotation" id="apidoc.element.jscodeshift.booleanTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>booleanTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.breakStatement" id="apidoc.element.jscodeshift.breakStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>breakStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">breakStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.callExpression" id="apidoc.element.jscodeshift.callExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>callExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

For example, the following creates an AST equivalent to `foo(bar)`:

```js
// inside a module transform
var j = jscodeshift;
// foo(bar);
var ast = j.<span class="apidocCodeKeywordSpan">callExpression</span>(
  j.identifier('foo'),
  [j.identifier('bar')]
);
```

The signature of each builder function is best learned by having a look at the
[definition files](https://github.com/benjamn/ast-types/blob/master/def/).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.callStatement" id="apidoc.element.jscodeshift.callStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>callStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.catchClause" id="apidoc.element.jscodeshift.catchClause">
        function <span class="apidocSignatureSpan">jscodeshift.</span>catchClause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catchClause = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.classBody" id="apidoc.element.jscodeshift.classBody">
        function <span class="apidocSignatureSpan">jscodeshift.</span>classBody
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classBody = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.classDeclaration" id="apidoc.element.jscodeshift.classDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>classDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.classExpression" id="apidoc.element.jscodeshift.classExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>classExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.classImplements" id="apidoc.element.jscodeshift.classImplements">
        function <span class="apidocSignatureSpan">jscodeshift.</span>classImplements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classImplements = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.classMethod" id="apidoc.element.jscodeshift.classMethod">
        function <span class="apidocSignatureSpan">jscodeshift.</span>classMethod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classMethod = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.classProperty" id="apidoc.element.jscodeshift.classProperty">
        function <span class="apidocSignatureSpan">jscodeshift.</span>classProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.classPropertyDefinition" id="apidoc.element.jscodeshift.classPropertyDefinition">
        function <span class="apidocSignatureSpan">jscodeshift.</span>classPropertyDefinition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classPropertyDefinition = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.classStatement" id="apidoc.element.jscodeshift.classStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>classStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.commentBlock" id="apidoc.element.jscodeshift.commentBlock">
        function <span class="apidocSignatureSpan">jscodeshift.</span>commentBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commentBlock = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.commentLine" id="apidoc.element.jscodeshift.commentLine">
        function <span class="apidocSignatureSpan">jscodeshift.</span>commentLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commentLine = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.comprehensionBlock" id="apidoc.element.jscodeshift.comprehensionBlock">
        function <span class="apidocSignatureSpan">jscodeshift.</span>comprehensionBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionBlock = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.comprehensionExpression" id="apidoc.element.jscodeshift.comprehensionExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>comprehensionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.comprehensionStatement" id="apidoc.element.jscodeshift.comprehensionStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>comprehensionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.conditionalExpression" id="apidoc.element.jscodeshift.conditionalExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>conditionalExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditionalExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.conditionalStatement" id="apidoc.element.jscodeshift.conditionalStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>conditionalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditionalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.continueStatement" id="apidoc.element.jscodeshift.continueStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>continueStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.debuggerStatement" id="apidoc.element.jscodeshift.debuggerStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>debuggerStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debuggerStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.declareClass" id="apidoc.element.jscodeshift.declareClass">
        function <span class="apidocSignatureSpan">jscodeshift.</span>declareClass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareClass = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.declareExportAllDeclaration" id="apidoc.element.jscodeshift.declareExportAllDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>declareExportAllDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareExportAllDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.declareExportDeclaration" id="apidoc.element.jscodeshift.declareExportDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>declareExportDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareExportDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.declareFunction" id="apidoc.element.jscodeshift.declareFunction">
        function <span class="apidocSignatureSpan">jscodeshift.</span>declareFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareFunction = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.declareInterface" id="apidoc.element.jscodeshift.declareInterface">
        function <span class="apidocSignatureSpan">jscodeshift.</span>declareInterface
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareInterface = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.declareModule" id="apidoc.element.jscodeshift.declareModule">
        function <span class="apidocSignatureSpan">jscodeshift.</span>declareModule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareModule = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.declareModuleExports" id="apidoc.element.jscodeshift.declareModuleExports">
        function <span class="apidocSignatureSpan">jscodeshift.</span>declareModuleExports
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareModuleExports = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.declareTypeAlias" id="apidoc.element.jscodeshift.declareTypeAlias">
        function <span class="apidocSignatureSpan">jscodeshift.</span>declareTypeAlias
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareTypeAlias = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.declareVariable" id="apidoc.element.jscodeshift.declareVariable">
        function <span class="apidocSignatureSpan">jscodeshift.</span>declareVariable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareVariable = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.decorator" id="apidoc.element.jscodeshift.decorator">
        function <span class="apidocSignatureSpan">jscodeshift.</span>decorator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorator = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.directive" id="apidoc.element.jscodeshift.directive">
        function <span class="apidocSignatureSpan">jscodeshift.</span>directive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directive = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.directiveLiteral" id="apidoc.element.jscodeshift.directiveLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.</span>directiveLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directiveLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.directiveLiteralStatement" id="apidoc.element.jscodeshift.directiveLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>directiveLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directiveLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.doExpression" id="apidoc.element.jscodeshift.doExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>doExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.doStatement" id="apidoc.element.jscodeshift.doStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>doStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.doWhileStatement" id="apidoc.element.jscodeshift.doWhileStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>doWhileStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doWhileStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.emptyStatement" id="apidoc.element.jscodeshift.emptyStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>emptyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptyStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.emptyTypeAnnotation" id="apidoc.element.jscodeshift.emptyTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>emptyTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptyTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.existentialTypeParam" id="apidoc.element.jscodeshift.existentialTypeParam">
        function <span class="apidocSignatureSpan">jscodeshift.</span>existentialTypeParam
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existentialTypeParam = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.existsTypeAnnotation" id="apidoc.element.jscodeshift.existsTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>existsTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existsTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.exportAllDeclaration" id="apidoc.element.jscodeshift.exportAllDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>exportAllDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportAllDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.exportBatchSpecifier" id="apidoc.element.jscodeshift.exportBatchSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.</span>exportBatchSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportBatchSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.exportDeclaration" id="apidoc.element.jscodeshift.exportDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>exportDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.exportDefaultDeclaration" id="apidoc.element.jscodeshift.exportDefaultDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>exportDefaultDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDefaultDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.exportDefaultSpecifier" id="apidoc.element.jscodeshift.exportDefaultSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.</span>exportDefaultSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDefaultSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.exportNamedDeclaration" id="apidoc.element.jscodeshift.exportNamedDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>exportNamedDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportNamedDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.exportNamespaceSpecifier" id="apidoc.element.jscodeshift.exportNamespaceSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.</span>exportNamespaceSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportNamespaceSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.exportSpecifier" id="apidoc.element.jscodeshift.exportSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.</span>exportSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.expressionStatement" id="apidoc.element.jscodeshift.expressionStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>expressionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expressionStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.file" id="apidoc.element.jscodeshift.file">
        function <span class="apidocSignatureSpan">jscodeshift.</span>file
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.forAwaitStatement" id="apidoc.element.jscodeshift.forAwaitStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>forAwaitStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forAwaitStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.forInStatement" id="apidoc.element.jscodeshift.forInStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>forInStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forInStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.forOfStatement" id="apidoc.element.jscodeshift.forOfStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>forOfStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forOfStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.forStatement" id="apidoc.element.jscodeshift.forStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>forStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.functionDeclaration" id="apidoc.element.jscodeshift.functionDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>functionDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.functionExpression" id="apidoc.element.jscodeshift.functionExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>functionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.functionStatement" id="apidoc.element.jscodeshift.functionStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>functionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.functionTypeAnnotation" id="apidoc.element.jscodeshift.functionTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>functionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.functionTypeParam" id="apidoc.element.jscodeshift.functionTypeParam">
        function <span class="apidocSignatureSpan">jscodeshift.</span>functionTypeParam
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionTypeParam = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.generatorExpression" id="apidoc.element.jscodeshift.generatorExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>generatorExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generatorExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.generatorStatement" id="apidoc.element.jscodeshift.generatorStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>generatorStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generatorStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.genericTypeAnnotation" id="apidoc.element.jscodeshift.genericTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>genericTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">genericTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.graphExpression" id="apidoc.element.jscodeshift.graphExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>graphExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.graphIndexExpression" id="apidoc.element.jscodeshift.graphIndexExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>graphIndexExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphIndexExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.graphIndexStatement" id="apidoc.element.jscodeshift.graphIndexStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>graphIndexStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphIndexStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.graphStatement" id="apidoc.element.jscodeshift.graphStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>graphStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.identifier" id="apidoc.element.jscodeshift.identifier">
        function <span class="apidocSignatureSpan">jscodeshift.</span>identifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
For example, the following creates an AST equivalent to `foo(bar)`:

```js
// inside a module transform
var j = jscodeshift;
// foo(bar);
var ast = j.callExpression(
  j.<span class="apidocCodeKeywordSpan">identifier</span>('foo'),
  [j.identifier('bar')]
);
```

The signature of each builder function is best learned by having a look at the
[definition files](https://github.com/benjamn/ast-types/blob/master/def/).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.identifierStatement" id="apidoc.element.jscodeshift.identifierStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>identifierStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identifierStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.ifStatement" id="apidoc.element.jscodeshift.ifStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>ifStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ifStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.import" id="apidoc.element.jscodeshift.import">
        function <span class="apidocSignatureSpan">jscodeshift.</span>import
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.importDeclaration" id="apidoc.element.jscodeshift.importDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>importDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.importDefaultSpecifier" id="apidoc.element.jscodeshift.importDefaultSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.</span>importDefaultSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importDefaultSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.importNamespaceSpecifier" id="apidoc.element.jscodeshift.importNamespaceSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.</span>importNamespaceSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importNamespaceSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.importSpecifier" id="apidoc.element.jscodeshift.importSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.</span>importSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.importStatement" id="apidoc.element.jscodeshift.importStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>importStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.interfaceDeclaration" id="apidoc.element.jscodeshift.interfaceDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>interfaceDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interfaceDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.interfaceExtends" id="apidoc.element.jscodeshift.interfaceExtends">
        function <span class="apidocSignatureSpan">jscodeshift.</span>interfaceExtends
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interfaceExtends = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.intersectionTypeAnnotation" id="apidoc.element.jscodeshift.intersectionTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>intersectionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersectionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxAttribute" id="apidoc.element.jscodeshift.jsxAttribute">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxAttribute = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxClosingElement" id="apidoc.element.jscodeshift.jsxClosingElement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxClosingElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxClosingElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxElement" id="apidoc.element.jscodeshift.jsxElement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxElementStatement" id="apidoc.element.jscodeshift.jsxElementStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxElementStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxElementStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxEmptyExpression" id="apidoc.element.jscodeshift.jsxEmptyExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxEmptyExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxEmptyExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxEmptyStatement" id="apidoc.element.jscodeshift.jsxEmptyStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxEmptyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxEmptyStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxExpressionContainer" id="apidoc.element.jscodeshift.jsxExpressionContainer">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxExpressionContainer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxExpressionContainer = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxExpressionContainerStatement" id="apidoc.element.jscodeshift.jsxExpressionContainerStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxExpressionContainerStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxExpressionContainerStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxIdentifier" id="apidoc.element.jscodeshift.jsxIdentifier">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxIdentifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxIdentifierStatement" id="apidoc.element.jscodeshift.jsxIdentifierStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxIdentifierStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxIdentifierStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxMemberExpression" id="apidoc.element.jscodeshift.jsxMemberExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxMemberExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxMemberExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxMemberStatement" id="apidoc.element.jscodeshift.jsxMemberStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxMemberStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxMemberStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxNamespacedName" id="apidoc.element.jscodeshift.jsxNamespacedName">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxNamespacedName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxNamespacedName = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxOpeningElement" id="apidoc.element.jscodeshift.jsxOpeningElement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxOpeningElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxOpeningElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxSpreadAttribute" id="apidoc.element.jscodeshift.jsxSpreadAttribute">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxSpreadAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxSpreadAttribute = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxText" id="apidoc.element.jscodeshift.jsxText">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxText = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.jsxTextStatement" id="apidoc.element.jscodeshift.jsxTextStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>jsxTextStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxTextStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.labeledStatement" id="apidoc.element.jscodeshift.labeledStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>labeledStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">labeledStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.letExpression" id="apidoc.element.jscodeshift.letExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>letExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">letExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.letStatement" id="apidoc.element.jscodeshift.letStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>letStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">letStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.line" id="apidoc.element.jscodeshift.line">
        function <span class="apidocSignatureSpan">jscodeshift.</span>line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">line = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.literal" id="apidoc.element.jscodeshift.literal">
        function <span class="apidocSignatureSpan">jscodeshift.</span>literal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">literal = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.literalStatement" id="apidoc.element.jscodeshift.literalStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>literalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">literalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.logicalExpression" id="apidoc.element.jscodeshift.logicalExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>logicalExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logicalExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.logicalStatement" id="apidoc.element.jscodeshift.logicalStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>logicalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logicalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.match" id="apidoc.element.jscodeshift.match">
        function <span class="apidocSignatureSpan">jscodeshift.</span>match
        <span class="apidocSignatureSpan">(path, filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(path, filter) {
  if (!(path instanceof NodePath)) {
    if (typeof path.get === 'function') {
      path = path.get();
    } else {
      path = {value: path};
    }
  }
  return matchNode(path.value, filter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.memberExpression" id="apidoc.element.jscodeshift.memberExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>memberExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.memberStatement" id="apidoc.element.jscodeshift.memberStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>memberStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.memberTypeAnnotation" id="apidoc.element.jscodeshift.memberTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>memberTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.metaProperty" id="apidoc.element.jscodeshift.metaProperty">
        function <span class="apidocSignatureSpan">jscodeshift.</span>metaProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">metaProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.metaPropertyStatement" id="apidoc.element.jscodeshift.metaPropertyStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>metaPropertyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">metaPropertyStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.methodDefinition" id="apidoc.element.jscodeshift.methodDefinition">
        function <span class="apidocSignatureSpan">jscodeshift.</span>methodDefinition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">methodDefinition = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.mixedTypeAnnotation" id="apidoc.element.jscodeshift.mixedTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>mixedTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixedTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.newExpression" id="apidoc.element.jscodeshift.newExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>newExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.newStatement" id="apidoc.element.jscodeshift.newStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>newStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.noop" id="apidoc.element.jscodeshift.noop">
        function <span class="apidocSignatureSpan">jscodeshift.</span>noop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noop = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.nullLiteral" id="apidoc.element.jscodeshift.nullLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.</span>nullLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.nullLiteralStatement" id="apidoc.element.jscodeshift.nullLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>nullLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.nullLiteralTypeAnnotation" id="apidoc.element.jscodeshift.nullLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>nullLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.nullTypeAnnotation" id="apidoc.element.jscodeshift.nullTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>nullTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.nullableTypeAnnotation" id="apidoc.element.jscodeshift.nullableTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>nullableTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullableTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.numberLiteralTypeAnnotation" id="apidoc.element.jscodeshift.numberLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>numberLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.numberTypeAnnotation" id="apidoc.element.jscodeshift.numberTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>numberTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.numericLiteral" id="apidoc.element.jscodeshift.numericLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.</span>numericLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.numericLiteralStatement" id="apidoc.element.jscodeshift.numericLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>numericLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.numericLiteralTypeAnnotation" id="apidoc.element.jscodeshift.numericLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>numericLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.objectExpression" id="apidoc.element.jscodeshift.objectExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>objectExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.objectMethod" id="apidoc.element.jscodeshift.objectMethod">
        function <span class="apidocSignatureSpan">jscodeshift.</span>objectMethod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectMethod = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.objectPattern" id="apidoc.element.jscodeshift.objectPattern">
        function <span class="apidocSignatureSpan">jscodeshift.</span>objectPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.objectProperty" id="apidoc.element.jscodeshift.objectProperty">
        function <span class="apidocSignatureSpan">jscodeshift.</span>objectProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.objectStatement" id="apidoc.element.jscodeshift.objectStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>objectStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.objectTypeAnnotation" id="apidoc.element.jscodeshift.objectTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>objectTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.objectTypeCallProperty" id="apidoc.element.jscodeshift.objectTypeCallProperty">
        function <span class="apidocSignatureSpan">jscodeshift.</span>objectTypeCallProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeCallProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.objectTypeIndexer" id="apidoc.element.jscodeshift.objectTypeIndexer">
        function <span class="apidocSignatureSpan">jscodeshift.</span>objectTypeIndexer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeIndexer = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.objectTypeProperty" id="apidoc.element.jscodeshift.objectTypeProperty">
        function <span class="apidocSignatureSpan">jscodeshift.</span>objectTypeProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.parenthesizedExpression" id="apidoc.element.jscodeshift.parenthesizedExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>parenthesizedExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parenthesizedExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.parenthesizedStatement" id="apidoc.element.jscodeshift.parenthesizedStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>parenthesizedStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parenthesizedStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.position" id="apidoc.element.jscodeshift.position">
        function <span class="apidocSignatureSpan">jscodeshift.</span>position
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">position = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.program" id="apidoc.element.jscodeshift.program">
        function <span class="apidocSignatureSpan">jscodeshift.</span>program
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">program = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.property" id="apidoc.element.jscodeshift.property">
        function <span class="apidocSignatureSpan">jscodeshift.</span>property
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.propertyPattern" id="apidoc.element.jscodeshift.propertyPattern">
        function <span class="apidocSignatureSpan">jscodeshift.</span>propertyPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">propertyPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.qualifiedTypeIdentifier" id="apidoc.element.jscodeshift.qualifiedTypeIdentifier">
        function <span class="apidocSignatureSpan">jscodeshift.</span>qualifiedTypeIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">qualifiedTypeIdentifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.regExpLiteral" id="apidoc.element.jscodeshift.regExpLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.</span>regExpLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regExpLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.regExpLiteralStatement" id="apidoc.element.jscodeshift.regExpLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>regExpLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regExpLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.registerMethods" id="apidoc.element.jscodeshift.registerMethods">
        function <span class="apidocSignatureSpan">jscodeshift.</span>registerMethods
        <span class="apidocSignatureSpan">(methods, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function registerMethods(methods, type) {
  for (const methodName in methods) {
    if (!methods.hasOwnProperty(methodName)) {
      return;
    }
    if (hasConflictingRegistration(methodName, type)) {
      let msg = `There is a conflicting registration for method with name "${methodName}".\nYou tried to register an additional
method with `;

      if (type) {
        msg += `type "${type.toString()}".`
      } else {
        msg += 'universal type.'
      }

      msg += '\nThere are existing registrations for that method with ';

      const conflictingRegistrations = CPt[methodName].typedRegistrations;

      if (conflictingRegistrations) {
        msg += `type ${Object.keys(conflictingRegistrations).join(', ')}.`;
      } else {
        msg += 'universal type.';
      }

      throw Error(msg);
    }
    if (!type) {
      CPt[methodName] = methods[methodName];
    } else {
      type = type.toString();
      if (!CPt.hasOwnProperty(methodName)) {
        installTypedMethod(methodName);
      }
      var registrations = CPt[methodName].typedRegistrations;
      registrations[type] = methods[methodName];
      astTypes.getSupertypeNames(type).forEach(function (name) {
        registrations[name] = false;
      });
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the nodes in the collection. **Type-specific** extensions work only on specific
node types and are not callable on differently typed collections.

#### Examples

```js
// Adding a method to all Identifiers
jscodeshift.<span class="apidocCodeKeywordSpan">registerMethods</span>({
	logNames: function() {
		return this.forEach(function(path) {
			console.log(path.node.name);
		});
	}
}, jscodeshift.Identifier);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.restElement" id="apidoc.element.jscodeshift.restElement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>restElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.restProperty" id="apidoc.element.jscodeshift.restProperty">
        function <span class="apidocSignatureSpan">jscodeshift.</span>restProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.returnStatement" id="apidoc.element.jscodeshift.returnStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>returnStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">returnStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.sequenceExpression" id="apidoc.element.jscodeshift.sequenceExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>sequenceExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequenceExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.sequenceStatement" id="apidoc.element.jscodeshift.sequenceStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>sequenceStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequenceStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.sourceLocation" id="apidoc.element.jscodeshift.sourceLocation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>sourceLocation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sourceLocation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.spreadElement" id="apidoc.element.jscodeshift.spreadElement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>spreadElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.spreadElementPattern" id="apidoc.element.jscodeshift.spreadElementPattern">
        function <span class="apidocSignatureSpan">jscodeshift.</span>spreadElementPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadElementPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.spreadProperty" id="apidoc.element.jscodeshift.spreadProperty">
        function <span class="apidocSignatureSpan">jscodeshift.</span>spreadProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.spreadPropertyPattern" id="apidoc.element.jscodeshift.spreadPropertyPattern">
        function <span class="apidocSignatureSpan">jscodeshift.</span>spreadPropertyPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadPropertyPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.stringLiteral" id="apidoc.element.jscodeshift.stringLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.</span>stringLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.stringLiteralStatement" id="apidoc.element.jscodeshift.stringLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>stringLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.stringLiteralTypeAnnotation" id="apidoc.element.jscodeshift.stringLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>stringLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.stringTypeAnnotation" id="apidoc.element.jscodeshift.stringTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>stringTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.super" id="apidoc.element.jscodeshift.super">
        function <span class="apidocSignatureSpan">jscodeshift.</span>super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.superStatement" id="apidoc.element.jscodeshift.superStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>superStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.switchCase" id="apidoc.element.jscodeshift.switchCase">
        function <span class="apidocSignatureSpan">jscodeshift.</span>switchCase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchCase = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.switchStatement" id="apidoc.element.jscodeshift.switchStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>switchStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.taggedTemplateExpression" id="apidoc.element.jscodeshift.taggedTemplateExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>taggedTemplateExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">taggedTemplateExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.taggedTemplateStatement" id="apidoc.element.jscodeshift.taggedTemplateStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>taggedTemplateStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">taggedTemplateStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.templateElement" id="apidoc.element.jscodeshift.templateElement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>templateElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.templateLiteral" id="apidoc.element.jscodeshift.templateLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.</span>templateLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.templateLiteralStatement" id="apidoc.element.jscodeshift.templateLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>templateLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.thisExpression" id="apidoc.element.jscodeshift.thisExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>thisExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.thisStatement" id="apidoc.element.jscodeshift.thisStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>thisStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.thisTypeAnnotation" id="apidoc.element.jscodeshift.thisTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>thisTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.throwStatement" id="apidoc.element.jscodeshift.throwStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>throwStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.tryStatement" id="apidoc.element.jscodeshift.tryStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>tryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.tupleTypeAnnotation" id="apidoc.element.jscodeshift.tupleTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>tupleTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tupleTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.typeAlias" id="apidoc.element.jscodeshift.typeAlias">
        function <span class="apidocSignatureSpan">jscodeshift.</span>typeAlias
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeAlias = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.typeAnnotation" id="apidoc.element.jscodeshift.typeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>typeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.typeCastExpression" id="apidoc.element.jscodeshift.typeCastExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>typeCastExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeCastExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.typeCastStatement" id="apidoc.element.jscodeshift.typeCastStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>typeCastStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeCastStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.typeParameter" id="apidoc.element.jscodeshift.typeParameter">
        function <span class="apidocSignatureSpan">jscodeshift.</span>typeParameter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameter = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.typeParameterDeclaration" id="apidoc.element.jscodeshift.typeParameterDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>typeParameterDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameterDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.typeParameterInstantiation" id="apidoc.element.jscodeshift.typeParameterInstantiation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>typeParameterInstantiation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameterInstantiation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.typeofTypeAnnotation" id="apidoc.element.jscodeshift.typeofTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>typeofTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeofTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath" id="apidoc.element.jscodeshift.types.NodePath">
        function <span class="apidocSignatureSpan">jscodeshift.</span>types.NodePath
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodePath(value, parentPath, name) {
    if (!(this instanceof NodePath)) {
        throw new Error("NodePath constructor cannot be invoked without 'new'");
    }
    Path.call(this, value, parentPath, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path" id="apidoc.element.jscodeshift.types.Path">
        function <span class="apidocSignatureSpan">jscodeshift.</span>types.Path
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Path(value, parentPath, name) {
    if (!(this instanceof Path)) {
        throw new Error("Path constructor cannot be invoked without 'new'");
    }

    if (parentPath) {
        if (!(parentPath instanceof Path)) {
            throw new Error("");
        }
    } else {
        parentPath = null;
        name = null;
    }

    // The value encapsulated by this Path, generally equal to
    // parentPath.value[name] if we have a parentPath.
    this.value = value;

    // The immediate parent Path of this Path.
    this.parentPath = parentPath;

    // The name of the property of parentPath.value through which this
    // Path's value was reached.
    this.name = name;

    // Calling path.get("child") multiple times always returns the same
    // child Path object, for both performance and consistency reasons.
    this.__childCache = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor" id="apidoc.element.jscodeshift.types.PathVisitor">
        function <span class="apidocSignatureSpan">jscodeshift.</span>types.PathVisitor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PathVisitor() {
    if (!(this instanceof PathVisitor)) {
        throw new Error(
          "PathVisitor constructor cannot be invoked without 'new'"
        );
    }

    // Permanent state.
    this._reusableContextStack = [];

    this._methodNameTable = computeMethodNameTable(this);
    this._shouldVisitComments =
      hasOwn.call(this._methodNameTable, "Block") ||
      hasOwn.call(this._methodNameTable, "Line");

    this.Context = makeContextConstructor(this);

    // State reset every time PathVisitor.prototype.visit is called.
    this._visiting = false;
    this._changeReported = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Type" id="apidoc.element.jscodeshift.types.Type">
        function <span class="apidocSignatureSpan">jscodeshift.</span>types.Type
        <span class="apidocSignatureSpan">(check, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Type(check, name) {
    var self = this;
    if (!(self instanceof Type)) {
        throw new Error("Type constructor cannot be invoked without 'new'");
    }

    // Unfortunately we can't elegantly reuse isFunction and isString,
    // here, because this code is executed while defining those types.
    if (objToStr.call(check) !== funObjStr) {
        throw new Error(check + " is not a function");
    }

    // The `name` parameter can be either a function or a string.
    var nameObjStr = objToStr.call(name);
    if (!(nameObjStr === funObjStr ||
      nameObjStr === strObjStr)) {
        throw new Error(name + " is neither a function nor a string");
    }

    Object.defineProperties(self, {
        name: {value: name},
        check: {
            value: function (value, deep) {
                var result = check.call(self, value, deep);
                if (!result &amp;&amp; deep &amp;&amp; objToStr.call(deep) === funObjStr)
                    deep(self, value);
                return result;
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.astNodesAreEquivalent" id="apidoc.element.jscodeshift.types.astNodesAreEquivalent">
        function <span class="apidocSignatureSpan">jscodeshift.</span>types.astNodesAreEquivalent
        <span class="apidocSignatureSpan">(a, b, problemPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function astNodesAreEquivalent(a, b, problemPath) {
    if (isArray.check(problemPath)) {
        problemPath.length = 0;
    } else {
        problemPath = null;
    }

    return areEquivalent(a, b, problemPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.unaryExpression" id="apidoc.element.jscodeshift.unaryExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>unaryExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unaryExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.unaryStatement" id="apidoc.element.jscodeshift.unaryStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>unaryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unaryStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.unionTypeAnnotation" id="apidoc.element.jscodeshift.unionTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>unionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.updateExpression" id="apidoc.element.jscodeshift.updateExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>updateExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.updateStatement" id="apidoc.element.jscodeshift.updateStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>updateStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.use" id="apidoc.element.jscodeshift.use">
        function <span class="apidocSignatureSpan">jscodeshift.</span>use
        <span class="apidocSignatureSpan">(plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function use(plugin) {
  if (plugins.indexOf(plugin) === -1) {
    plugins.push(plugin);
    plugin(core);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.variableDeclaration" id="apidoc.element.jscodeshift.variableDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.</span>variableDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">variableDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.variableDeclarator" id="apidoc.element.jscodeshift.variableDeclarator">
        function <span class="apidocSignatureSpan">jscodeshift.</span>variableDeclarator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">variableDeclarator = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.voidTypeAnnotation" id="apidoc.element.jscodeshift.voidTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.</span>voidTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">voidTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.whileStatement" id="apidoc.element.jscodeshift.whileStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>whileStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whileStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.withParser" id="apidoc.element.jscodeshift.withParser">
        function <span class="apidocSignatureSpan">jscodeshift.</span>withParser
        <span class="apidocSignatureSpan">(parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function withParser(parser) {
  if (typeof parser === 'string') {
    parser = getParser(parser);
  }

  const newCore = function(source, options) {
    if (options &amp;&amp; !options.parser) {
      options.parser = parser;
    } else {
      options = {parser};
    }
    return core(source, options);
  };

  return enrichCore(newCore, parser);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.withStatement" id="apidoc.element.jscodeshift.withStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>withStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.yieldExpression" id="apidoc.element.jscodeshift.yieldExpression">
        function <span class="apidocSignatureSpan">jscodeshift.</span>yieldExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yieldExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.yieldStatement" id="apidoc.element.jscodeshift.yieldStatement">
        function <span class="apidocSignatureSpan">jscodeshift.</span>yieldStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yieldStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






































































































































































































































































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.babylon" id="apidoc.module.jscodeshift.babylon">module jscodeshift.babylon</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.babylon.parse" id="apidoc.element.jscodeshift.babylon.parse">
        function <span class="apidocSignatureSpan">jscodeshift.babylon.</span>parse
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(code) {
  return babylon.parse(code, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
collection.

Here is an example of how one would find/traverse all `Identifier` nodes with
jscodeshift and with recast:

```js
// recast
var ast = recast.<span class="apidocCodeKeywordSpan">parse</span>(src);
recast.visit(ast, {
  visitIdentifier: function(path) {
    // do something with path
    return false;
  }
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.flow" id="apidoc.module.jscodeshift.flow">module jscodeshift.flow</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.flow.parse" id="apidoc.element.jscodeshift.flow.parse">
        function <span class="apidocSignatureSpan">jscodeshift.flow.</span>parse
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(code) {
  return flowParser.parse(code, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
collection.

Here is an example of how one would find/traverse all `Identifier` nodes with
jscodeshift and with recast:

```js
// recast
var ast = recast.<span class="apidocCodeKeywordSpan">parse</span>(src);
recast.visit(ast, {
  visitIdentifier: function(path) {
    // do something with path
    return false;
  }
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.template" id="apidoc.module.jscodeshift.template">module jscodeshift.template</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.template.expression" id="apidoc.element.jscodeshift.template.expression">
        function <span class="apidocSignatureSpan">jscodeshift.template.</span>expression
        <span class="apidocSignatureSpan">(template)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expression(template) {
  // wrap code in `(...)` to force evaluation as expression
  template = Array.from(template);
  if (template.length &gt; 1) {
    template[0] = '(' + template[0];
    template[template.length - 1] += ')';
  } else if (template.length === 0) {
    template[0] = '(' + template[0] + ')';
  }

  return statement.apply(
    null,
    [template].concat(Array.from(arguments).slice(1))
  ).expression;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.template.statement" id="apidoc.element.jscodeshift.template.statement">
        function <span class="apidocSignatureSpan">jscodeshift.template.</span>statement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function statement() {
  return statements.apply(null, arguments)[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.template.statements" id="apidoc.element.jscodeshift.template.statements">
        function <span class="apidocSignatureSpan">jscodeshift.template.</span>statements
        <span class="apidocSignatureSpan">(template)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function statements(template) {
  template = Array.from(template);
  const nodes = Array.from(arguments).slice(1);
  const varNames = nodes.map(n =&gt; getRandomVarName());
  const src = template.reduce(
    (result, elem, i) =&gt; result + varNames[i - 1] + elem
  );

  return replaceNodes(
    src,
    varNames,
    nodes,
    parser
  ).program.body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.testUtils" id="apidoc.module.jscodeshift.testUtils">module jscodeshift.testUtils</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.testUtils.createTempFileWith" id="apidoc.element.jscodeshift.testUtils.createTempFileWith">
        function <span class="apidocSignatureSpan">jscodeshift.testUtils.</span>createTempFileWith
        <span class="apidocSignatureSpan">(content, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTempFileWith(content, filename) {
  const info = temp.openSync();
  let filePath = info.path;
  fs.writeSync(info.fd, content);
  fs.closeSync(info.fd);
  if (filename) {
    filePath = renameFileTo(filePath, filename);
  }
  return filePath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.testUtils.createTransformWith" id="apidoc.element.jscodeshift.testUtils.createTransformWith">
        function <span class="apidocSignatureSpan">jscodeshift.testUtils.</span>createTransformWith
        <span class="apidocSignatureSpan">(content, fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTransformWith(content, fileName) {
  return createTempFileWith(
    'module.exports = function(fileInfo, api, options) { ' + content + ' }',
    fileName
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.testUtils.getFileContent" id="apidoc.element.jscodeshift.testUtils.getFileContent">
        function <span class="apidocSignatureSpan">jscodeshift.testUtils.</span>getFileContent
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFileContent(filePath) {
  return fs.readFileSync(filePath).toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.types" id="apidoc.module.jscodeshift.types">module jscodeshift.types</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath" id="apidoc.element.jscodeshift.types.NodePath">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>NodePath
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodePath(value, parentPath, name) {
    if (!(this instanceof NodePath)) {
        throw new Error("NodePath constructor cannot be invoked without 'new'");
    }
    Path.call(this, value, parentPath, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path" id="apidoc.element.jscodeshift.types.Path">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>Path
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Path(value, parentPath, name) {
    if (!(this instanceof Path)) {
        throw new Error("Path constructor cannot be invoked without 'new'");
    }

    if (parentPath) {
        if (!(parentPath instanceof Path)) {
            throw new Error("");
        }
    } else {
        parentPath = null;
        name = null;
    }

    // The value encapsulated by this Path, generally equal to
    // parentPath.value[name] if we have a parentPath.
    this.value = value;

    // The immediate parent Path of this Path.
    this.parentPath = parentPath;

    // The name of the property of parentPath.value through which this
    // Path's value was reached.
    this.name = name;

    // Calling path.get("child") multiple times always returns the same
    // child Path object, for both performance and consistency reasons.
    this.__childCache = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor" id="apidoc.element.jscodeshift.types.PathVisitor">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>PathVisitor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PathVisitor() {
    if (!(this instanceof PathVisitor)) {
        throw new Error(
          "PathVisitor constructor cannot be invoked without 'new'"
        );
    }

    // Permanent state.
    this._reusableContextStack = [];

    this._methodNameTable = computeMethodNameTable(this);
    this._shouldVisitComments =
      hasOwn.call(this._methodNameTable, "Block") ||
      hasOwn.call(this._methodNameTable, "Line");

    this.Context = makeContextConstructor(this);

    // State reset every time PathVisitor.prototype.visit is called.
    this._visiting = false;
    this._changeReported = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Type" id="apidoc.element.jscodeshift.types.Type">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>Type
        <span class="apidocSignatureSpan">(check, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Type(check, name) {
    var self = this;
    if (!(self instanceof Type)) {
        throw new Error("Type constructor cannot be invoked without 'new'");
    }

    // Unfortunately we can't elegantly reuse isFunction and isString,
    // here, because this code is executed while defining those types.
    if (objToStr.call(check) !== funObjStr) {
        throw new Error(check + " is not a function");
    }

    // The `name` parameter can be either a function or a string.
    var nameObjStr = objToStr.call(name);
    if (!(nameObjStr === funObjStr ||
      nameObjStr === strObjStr)) {
        throw new Error(name + " is neither a function nor a string");
    }

    Object.defineProperties(self, {
        name: {value: name},
        check: {
            value: function (value, deep) {
                var result = check.call(self, value, deep);
                if (!result &amp;&amp; deep &amp;&amp; objToStr.call(deep) === funObjStr)
                    deep(self, value);
                return result;
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.astNodesAreEquivalent" id="apidoc.element.jscodeshift.types.astNodesAreEquivalent">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>astNodesAreEquivalent
        <span class="apidocSignatureSpan">(a, b, problemPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function astNodesAreEquivalent(a, b, problemPath) {
    if (isArray.check(problemPath)) {
        problemPath.length = 0;
    } else {
        problemPath = null;
    }

    return areEquivalent(a, b, problemPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.defineMethod" id="apidoc.element.jscodeshift.types.defineMethod">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>defineMethod
        <span class="apidocSignatureSpan">(name, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineMethod = function (name, func) {
    var old = nodePrototype[name];

    // Pass undefined as func to delete nodePrototype[name].
    if (isUndefined.check(func)) {
        delete nodePrototype[name];

    } else {
        isFunction.assert(func);

        Object.defineProperty(nodePrototype, name, {
            enumerable: true, // For discoverability.
            configurable: true, // For delete proto[name].
            value: func
        });
    }

    return old;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.eachField" id="apidoc.element.jscodeshift.types.eachField">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>eachField
        <span class="apidocSignatureSpan">(object, callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachField = function (object, callback, context) {
    getFieldNames(object).forEach(function (name) {
        callback.call(this, name, getFieldValue(object, name));
    }, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.finalize" id="apidoc.element.jscodeshift.types.finalize">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>finalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function () {
    Object.keys(defCache).forEach(function (name) {
        defCache[name].finalize();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.getFieldNames" id="apidoc.element.jscodeshift.types.getFieldNames">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>getFieldNames
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFieldNames(object) {
    var d = Def.fromValue(object);
    if (d) {
        return d.fieldNames.slice(0);
    }

    if ("type" in object) {
        throw new Error(
          "did not recognize object of type " +
          JSON.stringify(object.type)
        );
    }

    return Object.keys(object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.getFieldValue" id="apidoc.element.jscodeshift.types.getFieldValue">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>getFieldValue
        <span class="apidocSignatureSpan">(object, fieldName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFieldValue(object, fieldName) {
    var d = Def.fromValue(object);
    if (d) {
        var field = d.allFields[fieldName];
        if (field) {
            return field.getValue(object);
        }
    }

    return object &amp;&amp; object[fieldName];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.getSupertypeNames" id="apidoc.element.jscodeshift.types.getSupertypeNames">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>getSupertypeNames
        <span class="apidocSignatureSpan">(typeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSupertypeNames = function (typeName) {
    if (!hasOwn.call(defCache, typeName)) {
        throw new Error("");
    }
    var d = defCache[typeName];
    if (d.finalized !== true) {
        throw new Error("");
    }
    return d.supertypeList.slice(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.someField" id="apidoc.element.jscodeshift.types.someField">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>someField
        <span class="apidocSignatureSpan">(object, callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someField = function (object, callback, context) {
    return getFieldNames(object).some(function (name) {
        return callback.call(this, name, getFieldValue(object, name));
    }, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.use" id="apidoc.element.jscodeshift.types.use">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>use
        <span class="apidocSignatureSpan">(plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function use(plugin) {
    var idx = used.indexOf(plugin);
    if (idx === -1) {
        idx = used.length;
        used.push(plugin);
        usedResult[idx] = plugin(fork);
    }
    return usedResult[idx];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.visit" id="apidoc.element.jscodeshift.types.visit">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>visit
        <span class="apidocSignatureSpan">(node, methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visit(node, methods) {
    return PathVisitor.fromMethodsObject(methods).visit(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Here is an example of how one would find/traverse all `Identifier` nodes with
jscodeshift and with recast:

```js
// recast
var ast = recast.parse(src);
recast.<span class="apidocCodeKeywordSpan">visit</span>(ast, {
  visitIdentifier: function(path) {
    // do something with path
    return false;
  }
});

// jscodeshift
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.types.NodePath" id="apidoc.module.jscodeshift.types.NodePath">module jscodeshift.types.NodePath</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath.NodePath" id="apidoc.element.jscodeshift.types.NodePath.NodePath">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>NodePath
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodePath(value, parentPath, name) {
    if (!(this instanceof NodePath)) {
        throw new Error("NodePath constructor cannot be invoked without 'new'");
    }
    Path.call(this, value, parentPath, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.types.NodePath.prototype" id="apidoc.module.jscodeshift.types.NodePath.prototype">module jscodeshift.types.NodePath.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath.prototype._computeNode" id="apidoc.element.jscodeshift.types.NodePath.prototype._computeNode">
        function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>_computeNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_computeNode = function () {
    var value = this.value;
    if (n.Node.check(value)) {
        return value;
    }

    var pp = this.parentPath;
    return pp &amp;&amp; pp.node || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath.prototype._computeParent" id="apidoc.element.jscodeshift.types.NodePath.prototype._computeParent">
        function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>_computeParent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_computeParent = function () {
    var value = this.value;
    var pp = this.parentPath;

    if (!n.Node.check(value)) {
        while (pp &amp;&amp; !n.Node.check(pp.value)) {
            pp = pp.parentPath;
        }

        if (pp) {
            pp = pp.parentPath;
        }
    }

    while (pp &amp;&amp; !n.Node.check(pp.value)) {
        pp = pp.parentPath;
    }

    return pp || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath.prototype._computeScope" id="apidoc.element.jscodeshift.types.NodePath.prototype._computeScope">
        function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>_computeScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_computeScope = function () {
    var value = this.value;
    var pp = this.parentPath;
    var scope = pp &amp;&amp; pp.scope;

    if (n.Node.check(value) &amp;&amp;
      Scope.isEstablishedBy(value)) {
        scope = new Scope(this, scope);
    }

    return scope || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath.prototype.canBeFirstInStatement" id="apidoc.element.jscodeshift.types.NodePath.prototype.canBeFirstInStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>canBeFirstInStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canBeFirstInStatement = function () {
    var node = this.node;
    return !n.FunctionExpression.check(node)
      &amp;&amp; !n.ObjectExpression.check(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath.prototype.firstInStatement" id="apidoc.element.jscodeshift.types.NodePath.prototype.firstInStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>firstInStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">firstInStatement = function () {
    return firstInStatement(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath.prototype.getValueProperty" id="apidoc.element.jscodeshift.types.NodePath.prototype.getValueProperty">
        function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>getValueProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValueProperty = function (name) {
    return types.getFieldValue(this.value, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath.prototype.needsParens" id="apidoc.element.jscodeshift.types.NodePath.prototype.needsParens">
        function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>needsParens
        <span class="apidocSignatureSpan">(assumeExpressionContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">needsParens = function (assumeExpressionContext) {
    var pp = this.parentPath;
    if (!pp) {
        return false;
    }

    var node = this.value;

    // Only expressions need parentheses.
    if (!n.Expression.check(node)) {
        return false;
    }

    // Identifiers never need parentheses.
    if (node.type === "Identifier") {
        return false;
    }

    while (!n.Node.check(pp.value)) {
        pp = pp.parentPath;
        if (!pp) {
            return false;
        }
    }

    var parent = pp.value;

    switch (node.type) {
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
            return parent.type === "MemberExpression"
              &amp;&amp; this.name === "object"
              &amp;&amp; parent.object === node;

        case "BinaryExpression":
        case "LogicalExpression":
            switch (parent.type) {
                case "CallExpression":
                    return this.name === "callee"
                      &amp;&amp; parent.callee === node;

                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                    return true;

                case "MemberExpression":
                    return this.name === "object"
                      &amp;&amp; parent.object === node;

                case "BinaryExpression":
                case "LogicalExpression":
                    var po = parent.operator;
                    var pp = PRECEDENCE[po];
                    var no = node.operator;
                    var np = PRECEDENCE[no];

                    if (pp &gt; np) {
                        return true;
                    }

                    if (pp === np &amp;&amp; this.name === "right") {
                        if (parent.right !== node) {
                            throw new Error("Nodes must be equal");
                        }
                        return true;
                    }

                default:
                    return false;
            }

        case "SequenceExpression":
            switch (parent.type) {
                case "ForStatement":
                    // Although parentheses wouldn't hurt around sequence
                    // expressions in the head of for loops, traditional style
                    // dictates that e.g. i++, j++ should not be wrapped with
                    // parentheses.
                    return false;

                case "ExpressionStatement":
                    return this.name !== "expression";

                default:
                    // Otherwise err on the side of overparenthesization, adding
                    // explicit exceptions above if this proves overzealous.
                    return true;
            }

        case "YieldExpression":
            switch (parent.type) {
                case "BinaryExpression":
                case "LogicalExpression":
                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                case "CallExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ConditionalExpression":
                case "YieldExpression":
                    return true;

                default:
                    return false;
            }

        case "Literal":
            return parent.type === "MemberExpression"
              &amp;&amp; isNumber.check(node.value)
              &amp;&amp; this.name === "object"
              &amp;&amp; parent.object === node;

        case "AssignmentExpression":
        case "ConditionalExpression":
            switch (parent.type) {
                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                case "BinaryExpression":
                case "LogicalExpression":
                    return true;

                case "CallExpression":
                    return this.name === "callee"
                      &amp;&amp; parent.callee === node;

                case "ConditionalExpression":
                    return this.name === " ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath.prototype.prune" id="apidoc.element.jscodeshift.types.NodePath.prototype.prune">
        function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>prune
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prune = function () {
    var remainingNodePath = this.parent;

    this.replace();

    return cleanUpNodesAfterPrune(remainingNodePath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.NodePath.prototype.replace" id="apidoc.element.jscodeshift.types.NodePath.prototype.replace">
        function <span class="apidocSignatureSpan">jscodeshift.types.NodePath.prototype.</span>replace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function () {
    delete this.node;
    delete this.parent;
    delete this.scope;
    return Path.prototype.replace.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.types.Path" id="apidoc.module.jscodeshift.types.Path">module jscodeshift.types.Path</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.Path" id="apidoc.element.jscodeshift.types.Path.Path">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>Path
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Path(value, parentPath, name) {
    if (!(this instanceof Path)) {
        throw new Error("Path constructor cannot be invoked without 'new'");
    }

    if (parentPath) {
        if (!(parentPath instanceof Path)) {
            throw new Error("");
        }
    } else {
        parentPath = null;
        name = null;
    }

    // The value encapsulated by this Path, generally equal to
    // parentPath.value[name] if we have a parentPath.
    this.value = value;

    // The immediate parent Path of this Path.
    this.parentPath = parentPath;

    // The name of the property of parentPath.value through which this
    // Path's value was reached.
    this.name = name;

    // Calling path.get("child") multiple times always returns the same
    // child Path object, for both performance and consistency reasons.
    this.__childCache = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.types.Path.prototype" id="apidoc.module.jscodeshift.types.Path.prototype">module jscodeshift.types.Path.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.each" id="apidoc.element.jscodeshift.types.Path.prototype.each">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>each
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(callback, context) {
    var childPaths = [];
    var len = this.value.length;
    var i = 0;

    // Collect all the original child paths before invoking the callback.
    for (var i = 0; i &lt; len; ++i) {
        if (hasOwn.call(this.value, i)) {
            childPaths[i] = this.get(i);
        }
    }

    // Invoke the callback on just the original child paths, regardless of
    // any modifications made to the array by the callback. I chose these
    // semantics over cleverly invoking the callback on new elements because
    // this way is much easier to reason about.
    context = context || this;
    for (i = 0; i &lt; len; ++i) {
        if (hasOwn.call(childPaths, i)) {
            callback.call(context, childPaths[i]);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.filter" id="apidoc.element.jscodeshift.types.Path.prototype.filter">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>filter
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(callback, context) {
    var result = [];

    this.each(function (childPath) {
        if (callback.call(this, childPath)) {
            result.push(childPath);
        }
    }, context);

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.get" id="apidoc.element.jscodeshift.types.Path.prototype.get">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>get
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(name) {
    var path = this;
    var names = arguments;
    var count = names.length;

    for (var i = 0; i &lt; count; ++i) {
        path = getChildPath(path, names[i]);
    }

    return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.getValueProperty" id="apidoc.element.jscodeshift.types.Path.prototype.getValueProperty">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>getValueProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getValueProperty(name) {
    return this.value[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.insertAfter" id="apidoc.element.jscodeshift.types.Path.prototype.insertAfter">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>insertAfter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insertAfter(node) {
    var pp = this.parentPath;
    var argc = arguments.length;
    var insertAtArgs = [this.name + 1];
    for (var i = 0; i &lt; argc; ++i) {
        insertAtArgs.push(arguments[i]);
    }
    return pp.insertAt.apply(pp, insertAtArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.insertAt" id="apidoc.element.jscodeshift.types.Path.prototype.insertAt">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>insertAt
        <span class="apidocSignatureSpan">(index, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insertAt(index, node) {
    var argc = arguments.length;
    var move = getMoves(this, argc - 1, index);
    if (move === emptyMoves) {
        return this;
    }

    index = Math.max(index, 0);

    for (var i = 1; i &lt; argc; ++i) {
        this.value[index + i - 1] = arguments[i];
    }

    move();

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.insertBefore" id="apidoc.element.jscodeshift.types.Path.prototype.insertBefore">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>insertBefore
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insertBefore(node) {
    var pp = this.parentPath;
    var argc = arguments.length;
    var insertAtArgs = [this.name];
    for (var i = 0; i &lt; argc; ++i) {
        insertAtArgs.push(arguments[i]);
    }
    return pp.insertAt.apply(pp, insertAtArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.map" id="apidoc.element.jscodeshift.types.Path.prototype.map">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>map
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(callback, context) {
    var result = [];

    this.each(function (childPath) {
        result.push(callback.call(this, childPath));
    }, context);

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.pop" id="apidoc.element.jscodeshift.types.Path.prototype.pop">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pop() {
    isArray.assert(this.value);
    var cache = getChildCache(this);
    delete cache[this.value.length - 1];
    delete cache.length;
    return this.value.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.push" id="apidoc.element.jscodeshift.types.Path.prototype.push">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>push
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function push(node) {
    isArray.assert(this.value);
    delete getChildCache(this).length
    return this.value.push.apply(this.value, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.replace" id="apidoc.element.jscodeshift.types.Path.prototype.replace">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>replace
        <span class="apidocSignatureSpan">(replacement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(replacement) {
    var results = [];
    var parentValue = this.parentPath.value;
    var parentCache = getChildCache(this.parentPath);
    var count = arguments.length;

    repairRelationshipWithParent(this);

    if (isArray.check(parentValue)) {
        var originalLength = parentValue.length;
        var move = getMoves(this.parentPath, count - 1, this.name + 1);

        var spliceArgs = [this.name, 1];
        for (var i = 0; i &lt; count; ++i) {
            spliceArgs.push(arguments[i]);
        }

        var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);

        if (splicedOut[0] !== this.value) {
            throw new Error("");
        }
        if (parentValue.length !== (originalLength - 1 + count)) {
            throw new Error("");
        }

        move();

        if (count === 0) {
            delete this.value;
            delete parentCache[this.name];
            this.__childCache = null;

        } else {
            if (parentValue[this.name] !== replacement) {
                throw new Error("");
            }

            if (this.value !== replacement) {
                this.value = replacement;
                this.__childCache = null;
            }

            for (i = 0; i &lt; count; ++i) {
                results.push(this.parentPath.get(this.name + i));
            }

            if (results[0] !== this) {
                throw new Error("");
            }
        }

    } else if (count === 1) {
        if (this.value !== replacement) {
            this.__childCache = null;
        }
        this.value = parentValue[this.name] = replacement;
        results.push(this);

    } else if (count === 0) {
        delete parentValue[this.name];
        delete this.value;
        this.__childCache = null;

        // Leave this path cached as parentCache[this.name], even though
        // it no longer has a value defined.

    } else {
        throw new Error("Could not replace path");
    }

    return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.shift" id="apidoc.element.jscodeshift.types.Path.prototype.shift">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shift() {
    var move = getMoves(this, -1);
    var result = this.value.shift();
    move();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Path.prototype.unshift" id="apidoc.element.jscodeshift.types.Path.prototype.unshift">
        function <span class="apidocSignatureSpan">jscodeshift.types.Path.prototype.</span>unshift
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unshift(node) {
    var move = getMoves(this, arguments.length);
    var result = this.value.unshift.apply(this.value, arguments);
    move();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.types.PathVisitor" id="apidoc.module.jscodeshift.types.PathVisitor">module jscodeshift.types.PathVisitor</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.PathVisitor" id="apidoc.element.jscodeshift.types.PathVisitor.PathVisitor">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>PathVisitor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PathVisitor() {
    if (!(this instanceof PathVisitor)) {
        throw new Error(
          "PathVisitor constructor cannot be invoked without 'new'"
        );
    }

    // Permanent state.
    this._reusableContextStack = [];

    this._methodNameTable = computeMethodNameTable(this);
    this._shouldVisitComments =
      hasOwn.call(this._methodNameTable, "Block") ||
      hasOwn.call(this._methodNameTable, "Line");

    this.Context = makeContextConstructor(this);

    // State reset every time PathVisitor.prototype.visit is called.
    this._visiting = false;
    this._changeReported = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.fromMethodsObject" id="apidoc.element.jscodeshift.types.PathVisitor.fromMethodsObject">
        function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.</span>fromMethodsObject
        <span class="apidocSignatureSpan">(methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromMethodsObject(methods) {
    if (methods instanceof PathVisitor) {
        return methods;
    }

    if (!isObject.check(methods)) {
        // An empty visitor?
        return new PathVisitor;
    }

    function Visitor() {
        if (!(this instanceof Visitor)) {
            throw new Error(
              "Visitor constructor cannot be invoked without 'new'"
            );
        }
        PathVisitor.call(this);
    }

    var Vp = Visitor.prototype = Object.create(PVp);
    Vp.constructor = Visitor;

    extend(Vp, methods);
    extend(Visitor, PathVisitor);

    isFunction.assert(Visitor.fromMethodsObject);
    isFunction.assert(Visitor.visit);

    return new Visitor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.visit" id="apidoc.element.jscodeshift.types.PathVisitor.visit">
        function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.</span>visit
        <span class="apidocSignatureSpan">(node, methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visit(node, methods) {
    return PathVisitor.fromMethodsObject(methods).visit(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Here is an example of how one would find/traverse all `Identifier` nodes with
jscodeshift and with recast:

```js
// recast
var ast = recast.parse(src);
recast.<span class="apidocCodeKeywordSpan">visit</span>(ast, {
  visitIdentifier: function(path) {
    // do something with path
    return false;
  }
});

// jscodeshift
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.types.PathVisitor.prototype" id="apidoc.module.jscodeshift.types.PathVisitor.prototype">module jscodeshift.types.PathVisitor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.AbortRequest" id="apidoc.element.jscodeshift.types.PathVisitor.prototype.AbortRequest">
        function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>AbortRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbortRequest() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.abort" id="apidoc.element.jscodeshift.types.PathVisitor.prototype.abort">
        function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abort = function () {
    var visitor = this;
    visitor._abortRequested = true;
    var request = new visitor.AbortRequest();

    // If you decide to catch this exception and stop it from propagating,
    // make sure to call its cancel method to avoid silencing other
    // exceptions that might be thrown later in the traversal.
    request.cancel = function () {
        visitor._abortRequested = false;
    };

    throw request;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.acquireContext" id="apidoc.element.jscodeshift.types.PathVisitor.prototype.acquireContext">
        function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>acquireContext
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acquireContext = function (path) {
    if (this._reusableContextStack.length === 0) {
        return new this.Context(path);
    }
    return this._reusableContextStack.pop().reset(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.releaseContext" id="apidoc.element.jscodeshift.types.PathVisitor.prototype.releaseContext">
        function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>releaseContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">releaseContext = function (context) {
    if (!(context instanceof this.Context)) {
        throw new Error("");
    }
    this._reusableContextStack.push(context);
    context.currentPath = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.reportChanged" id="apidoc.element.jscodeshift.types.PathVisitor.prototype.reportChanged">
        function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>reportChanged
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportChanged = function () {
    this._changeReported = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.reset" id="apidoc.element.jscodeshift.types.PathVisitor.prototype.reset">
        function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>reset
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function (path) {
    // Empty stub; may be reassigned or overridden by subclasses.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.visit" id="apidoc.element.jscodeshift.types.PathVisitor.prototype.visit">
        function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>visit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visit = function () {
    if (this._visiting) {
        throw new Error(
          "Recursively calling visitor.visit(path) resets visitor state. " +
          "Try this.visit(path) or this.traverse(path) instead."
        );
    }

    // Private state that needs to be reset before every traversal.
    this._visiting = true;
    this._changeReported = false;
    this._abortRequested = false;

    var argc = arguments.length;
    var args = new Array(argc)
    for (var i = 0; i &lt; argc; ++i) {
        args[i] = arguments[i];
    }

    if (!(args[0] instanceof NodePath)) {
        args[0] = new NodePath({root: args[0]}).get("root");
    }

    // Called with the same arguments as .visit.
    this.reset.apply(this, args);

    try {
        var root = this.visitWithoutReset(args[0]);
        var didNotThrow = true;
    } finally {
        this._visiting = false;

        if (!didNotThrow &amp;&amp; this._abortRequested) {
            // If this.visitWithoutReset threw an exception and
            // this._abortRequested was set to true, return the root of
            // the AST instead of letting the exception propagate, so that
            // client code does not have to provide a try-catch block to
            // intercept the AbortRequest exception.  Other kinds of
            // exceptions will propagate without being intercepted and
            // rethrown by a catch block, so their stacks will accurately
            // reflect the original throwing context.
            return args[0].value;
        }
    }

    return root;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Here is an example of how one would find/traverse all `Identifier` nodes with
jscodeshift and with recast:

```js
// recast
var ast = recast.parse(src);
recast.<span class="apidocCodeKeywordSpan">visit</span>(ast, {
  visitIdentifier: function(path) {
    // do something with path
    return false;
  }
});

// jscodeshift
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.visitWithoutReset" id="apidoc.element.jscodeshift.types.PathVisitor.prototype.visitWithoutReset">
        function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>visitWithoutReset
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitWithoutReset = function (path) {
    if (this instanceof this.Context) {
        // Since this.Context.prototype === this, there's a chance we
        // might accidentally call context.visitWithoutReset. If that
        // happens, re-invoke the method against context.visitor.
        return this.visitor.visitWithoutReset(path);
    }

    if (!(path instanceof NodePath)) {
        throw new Error("");
    }

    var value = path.value;

    var methodName = value &amp;&amp;
      typeof value === "object" &amp;&amp;
      typeof value.type === "string" &amp;&amp;
      this._methodNameTable[value.type];

    if (methodName) {
        var context = this.acquireContext(path);
        try {
            return context.invokeVisitorMethod(methodName);
        } finally {
            this.releaseContext(context);
        }

    } else {
        // If there was no visitor method to call, visit the children of
        // this node generically.
        return visitChildren(path, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.PathVisitor.prototype.wasChangeReported" id="apidoc.element.jscodeshift.types.PathVisitor.prototype.wasChangeReported">
        function <span class="apidocSignatureSpan">jscodeshift.types.PathVisitor.prototype.</span>wasChangeReported
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wasChangeReported = function () {
    return this._changeReported;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.types.Type" id="apidoc.module.jscodeshift.types.Type">module jscodeshift.types.Type</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.types.Type.Type" id="apidoc.element.jscodeshift.types.Type.Type">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>Type
        <span class="apidocSignatureSpan">(check, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Type(check, name) {
    var self = this;
    if (!(self instanceof Type)) {
        throw new Error("Type constructor cannot be invoked without 'new'");
    }

    // Unfortunately we can't elegantly reuse isFunction and isString,
    // here, because this code is executed while defining those types.
    if (objToStr.call(check) !== funObjStr) {
        throw new Error(check + " is not a function");
    }

    // The `name` parameter can be either a function or a string.
    var nameObjStr = objToStr.call(name);
    if (!(nameObjStr === funObjStr ||
      nameObjStr === strObjStr)) {
        throw new Error(name + " is neither a function nor a string");
    }

    Object.defineProperties(self, {
        name: {value: name},
        check: {
            value: function (value, deep) {
                var result = check.call(self, value, deep);
                if (!result &amp;&amp; deep &amp;&amp; objToStr.call(deep) === funObjStr)
                    deep(self, value);
                return result;
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Type.def" id="apidoc.element.jscodeshift.types.Type.def">
        function <span class="apidocSignatureSpan">jscodeshift.types.Type.</span>def
        <span class="apidocSignatureSpan">(typeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">def = function (typeName) {
    isString.assert(typeName);
    return hasOwn.call(defCache, typeName)
      ? defCache[typeName]
      : defCache[typeName] = new Def(typeName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Type.fromArray" id="apidoc.element.jscodeshift.types.Type.fromArray">
        function <span class="apidocSignatureSpan">jscodeshift.types.Type.</span>fromArray
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromArray = function (arr) {
    if (!isArray.check(arr)) {
        throw new Error("");
    }
    if (arr.length !== 1) {
        throw new Error("only one element type is permitted for typed arrays");
    }
    return toType(arr[0]).arrayOf();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Type.fromObject" id="apidoc.element.jscodeshift.types.Type.fromObject">
        function <span class="apidocSignatureSpan">jscodeshift.types.Type.</span>fromObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromObject = function (obj) {
    var fields = Object.keys(obj).map(function (name) {
        return new Field(name, obj[name]);
    });

    return new Type(function (value, deep) {
        return isObject.check(value) &amp;&amp; fields.every(function (field) {
              return field.type.check(value[field.name], deep);
          });
    }, function () {
        return "{ " + fields.join(", ") + " }";
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Type.or" id="apidoc.element.jscodeshift.types.Type.or">
        function <span class="apidocSignatureSpan">jscodeshift.types.Type.</span>or
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">or = function () {
    var types = [];
    var len = arguments.length;
    for (var i = 0; i &lt; len; ++i)
        types.push(toType(arguments[i]));

    return new Type(function (value, deep) {
        for (var i = 0; i &lt; len; ++i)
            if (types[i].check(value, deep))
                return true;
        return false;
    }, function () {
        return types.join(" | ");
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.types.Type.prototype" id="apidoc.module.jscodeshift.types.Type.prototype">module jscodeshift.types.Type.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.types.Type.prototype.arrayOf" id="apidoc.element.jscodeshift.types.Type.prototype.arrayOf">
        function <span class="apidocSignatureSpan">jscodeshift.types.Type.prototype.</span>arrayOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayOf = function () {
    var elemType = this;
    return new Type(function (value, deep) {
        return isArray.check(value) &amp;&amp; value.every(function (elem) {
              return elemType.check(elem, deep);
          });
    }, function () {
        return "[" + elemType + "]";
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Type.prototype.assert" id="apidoc.element.jscodeshift.types.Type.prototype.assert">
        function <span class="apidocSignatureSpan">jscodeshift.types.Type.prototype.</span>assert
        <span class="apidocSignatureSpan">(value, deep)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assert = function (value, deep) {
    if (!this.check(value, deep)) {
        var str = shallowStringify(value);
        throw new Error(str + " does not match type " + this);
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.Type.prototype.toString" id="apidoc.element.jscodeshift.types.Type.prototype.toString">
        function <span class="apidocSignatureSpan">jscodeshift.types.Type.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    var name = this.name;

    if (isString.check(name))
        return name;

    if (isFunction.check(name))
        return name.call(this) + "";

    return name + " type";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'module.exports = function(fileInfo, api, options) { ' + content + ' }',
    fileName
  );
}
exports.createTransformWith = createTransformWith;

function getFileContent(filePath) {
  return fs.readFileSync(filePath).<span class="apidocCodeKeywordSpan">toString</span>();
}
exports.getFileContent = getFileContent;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.types.astNodesAreEquivalent" id="apidoc.module.jscodeshift.types.astNodesAreEquivalent">module jscodeshift.types.astNodesAreEquivalent</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.types.astNodesAreEquivalent.astNodesAreEquivalent" id="apidoc.element.jscodeshift.types.astNodesAreEquivalent.astNodesAreEquivalent">
        function <span class="apidocSignatureSpan">jscodeshift.types.</span>astNodesAreEquivalent
        <span class="apidocSignatureSpan">(a, b, problemPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function astNodesAreEquivalent(a, b, problemPath) {
    if (isArray.check(problemPath)) {
        problemPath.length = 0;
    } else {
        problemPath = null;
    }

    return areEquivalent(a, b, problemPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.astNodesAreEquivalent.assert" id="apidoc.element.jscodeshift.types.astNodesAreEquivalent.assert">
        function <span class="apidocSignatureSpan">jscodeshift.types.astNodesAreEquivalent.</span>assert
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assert = function (a, b) {
    var problemPath = [];
    if (!astNodesAreEquivalent(a, b, problemPath)) {
        if (problemPath.length === 0) {
            if (a !== b) {
                throw new Error("Nodes must be equal");
            }
        } else {
            throw new Error(
              "Nodes differ in the following path: " +
              problemPath.map(subscriptForProperty).join("")
            );
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscodeshift.types.builders" id="apidoc.module.jscodeshift.types.builders">module jscodeshift.types.builders</a></h1>


    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.anyTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.anyTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>anyTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anyTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.arrayExpression" id="apidoc.element.jscodeshift.types.builders.arrayExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrayExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.arrayPattern" id="apidoc.element.jscodeshift.types.builders.arrayPattern">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrayPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.arrayStatement" id="apidoc.element.jscodeshift.types.builders.arrayStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrayStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.arrayTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.arrayTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrayTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.arrowFunctionExpression" id="apidoc.element.jscodeshift.types.builders.arrowFunctionExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrowFunctionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrowFunctionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.arrowFunctionStatement" id="apidoc.element.jscodeshift.types.builders.arrowFunctionStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>arrowFunctionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrowFunctionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.assignmentExpression" id="apidoc.element.jscodeshift.types.builders.assignmentExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>assignmentExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.assignmentPattern" id="apidoc.element.jscodeshift.types.builders.assignmentPattern">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>assignmentPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.assignmentStatement" id="apidoc.element.jscodeshift.types.builders.assignmentStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>assignmentStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.awaitExpression" id="apidoc.element.jscodeshift.types.builders.awaitExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>awaitExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">awaitExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.awaitStatement" id="apidoc.element.jscodeshift.types.builders.awaitStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>awaitStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">awaitStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.binaryExpression" id="apidoc.element.jscodeshift.types.builders.binaryExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>binaryExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binaryExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.binaryStatement" id="apidoc.element.jscodeshift.types.builders.binaryStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>binaryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binaryStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.bindExpression" id="apidoc.element.jscodeshift.types.builders.bindExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>bindExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.bindStatement" id="apidoc.element.jscodeshift.types.builders.bindStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>bindStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.block" id="apidoc.element.jscodeshift.types.builders.block">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>block
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.blockStatement" id="apidoc.element.jscodeshift.types.builders.blockStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>blockStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blockStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.booleanLiteral" id="apidoc.element.jscodeshift.types.builders.booleanLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>booleanLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.booleanLiteralStatement" id="apidoc.element.jscodeshift.types.builders.booleanLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>booleanLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.booleanLiteralTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.booleanLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>booleanLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.booleanTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.booleanTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>booleanTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.breakStatement" id="apidoc.element.jscodeshift.types.builders.breakStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>breakStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">breakStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.callExpression" id="apidoc.element.jscodeshift.types.builders.callExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>callExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

For example, the following creates an AST equivalent to `foo(bar)`:

```js
// inside a module transform
var j = jscodeshift;
// foo(bar);
var ast = j.<span class="apidocCodeKeywordSpan">callExpression</span>(
  j.identifier('foo'),
  [j.identifier('bar')]
);
```

The signature of each builder function is best learned by having a look at the
[definition files](https://github.com/benjamn/ast-types/blob/master/def/).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.callStatement" id="apidoc.element.jscodeshift.types.builders.callStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>callStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.catchClause" id="apidoc.element.jscodeshift.types.builders.catchClause">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>catchClause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catchClause = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.classBody" id="apidoc.element.jscodeshift.types.builders.classBody">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classBody
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classBody = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.classDeclaration" id="apidoc.element.jscodeshift.types.builders.classDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.classExpression" id="apidoc.element.jscodeshift.types.builders.classExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.classImplements" id="apidoc.element.jscodeshift.types.builders.classImplements">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classImplements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classImplements = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.classMethod" id="apidoc.element.jscodeshift.types.builders.classMethod">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classMethod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classMethod = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.classProperty" id="apidoc.element.jscodeshift.types.builders.classProperty">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.classPropertyDefinition" id="apidoc.element.jscodeshift.types.builders.classPropertyDefinition">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classPropertyDefinition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classPropertyDefinition = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.classStatement" id="apidoc.element.jscodeshift.types.builders.classStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>classStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.commentBlock" id="apidoc.element.jscodeshift.types.builders.commentBlock">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>commentBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commentBlock = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.commentLine" id="apidoc.element.jscodeshift.types.builders.commentLine">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>commentLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commentLine = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.comprehensionBlock" id="apidoc.element.jscodeshift.types.builders.comprehensionBlock">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>comprehensionBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionBlock = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.comprehensionExpression" id="apidoc.element.jscodeshift.types.builders.comprehensionExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>comprehensionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.comprehensionStatement" id="apidoc.element.jscodeshift.types.builders.comprehensionStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>comprehensionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.conditionalExpression" id="apidoc.element.jscodeshift.types.builders.conditionalExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>conditionalExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditionalExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.conditionalStatement" id="apidoc.element.jscodeshift.types.builders.conditionalStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>conditionalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditionalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.continueStatement" id="apidoc.element.jscodeshift.types.builders.continueStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>continueStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.debuggerStatement" id="apidoc.element.jscodeshift.types.builders.debuggerStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>debuggerStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debuggerStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.declareClass" id="apidoc.element.jscodeshift.types.builders.declareClass">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareClass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareClass = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.declareExportAllDeclaration" id="apidoc.element.jscodeshift.types.builders.declareExportAllDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareExportAllDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareExportAllDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.declareExportDeclaration" id="apidoc.element.jscodeshift.types.builders.declareExportDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareExportDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareExportDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.declareFunction" id="apidoc.element.jscodeshift.types.builders.declareFunction">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareFunction = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.declareInterface" id="apidoc.element.jscodeshift.types.builders.declareInterface">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareInterface
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareInterface = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.declareModule" id="apidoc.element.jscodeshift.types.builders.declareModule">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareModule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareModule = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.declareModuleExports" id="apidoc.element.jscodeshift.types.builders.declareModuleExports">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareModuleExports
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareModuleExports = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.declareTypeAlias" id="apidoc.element.jscodeshift.types.builders.declareTypeAlias">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareTypeAlias
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareTypeAlias = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.declareVariable" id="apidoc.element.jscodeshift.types.builders.declareVariable">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>declareVariable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareVariable = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.decorator" id="apidoc.element.jscodeshift.types.builders.decorator">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>decorator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorator = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.directive" id="apidoc.element.jscodeshift.types.builders.directive">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>directive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directive = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.directiveLiteral" id="apidoc.element.jscodeshift.types.builders.directiveLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>directiveLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directiveLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.directiveLiteralStatement" id="apidoc.element.jscodeshift.types.builders.directiveLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>directiveLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directiveLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.doExpression" id="apidoc.element.jscodeshift.types.builders.doExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>doExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.doStatement" id="apidoc.element.jscodeshift.types.builders.doStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>doStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.doWhileStatement" id="apidoc.element.jscodeshift.types.builders.doWhileStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>doWhileStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doWhileStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.emptyStatement" id="apidoc.element.jscodeshift.types.builders.emptyStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>emptyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptyStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.emptyTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.emptyTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>emptyTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptyTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.existentialTypeParam" id="apidoc.element.jscodeshift.types.builders.existentialTypeParam">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>existentialTypeParam
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existentialTypeParam = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.existsTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.existsTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>existsTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existsTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.exportAllDeclaration" id="apidoc.element.jscodeshift.types.builders.exportAllDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportAllDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportAllDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.exportBatchSpecifier" id="apidoc.element.jscodeshift.types.builders.exportBatchSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportBatchSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportBatchSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.exportDeclaration" id="apidoc.element.jscodeshift.types.builders.exportDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.exportDefaultDeclaration" id="apidoc.element.jscodeshift.types.builders.exportDefaultDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportDefaultDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDefaultDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.exportDefaultSpecifier" id="apidoc.element.jscodeshift.types.builders.exportDefaultSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportDefaultSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDefaultSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.exportNamedDeclaration" id="apidoc.element.jscodeshift.types.builders.exportNamedDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportNamedDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportNamedDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.exportNamespaceSpecifier" id="apidoc.element.jscodeshift.types.builders.exportNamespaceSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportNamespaceSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportNamespaceSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.exportSpecifier" id="apidoc.element.jscodeshift.types.builders.exportSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>exportSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.expressionStatement" id="apidoc.element.jscodeshift.types.builders.expressionStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>expressionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expressionStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.file" id="apidoc.element.jscodeshift.types.builders.file">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>file
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.forAwaitStatement" id="apidoc.element.jscodeshift.types.builders.forAwaitStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>forAwaitStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forAwaitStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.forInStatement" id="apidoc.element.jscodeshift.types.builders.forInStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>forInStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forInStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.forOfStatement" id="apidoc.element.jscodeshift.types.builders.forOfStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>forOfStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forOfStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.forStatement" id="apidoc.element.jscodeshift.types.builders.forStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>forStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.functionDeclaration" id="apidoc.element.jscodeshift.types.builders.functionDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>functionDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.functionExpression" id="apidoc.element.jscodeshift.types.builders.functionExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>functionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.functionStatement" id="apidoc.element.jscodeshift.types.builders.functionStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>functionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.functionTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.functionTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>functionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.functionTypeParam" id="apidoc.element.jscodeshift.types.builders.functionTypeParam">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>functionTypeParam
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionTypeParam = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.generatorExpression" id="apidoc.element.jscodeshift.types.builders.generatorExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>generatorExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generatorExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.generatorStatement" id="apidoc.element.jscodeshift.types.builders.generatorStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>generatorStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generatorStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.genericTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.genericTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>genericTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">genericTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.graphExpression" id="apidoc.element.jscodeshift.types.builders.graphExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>graphExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.graphIndexExpression" id="apidoc.element.jscodeshift.types.builders.graphIndexExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>graphIndexExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphIndexExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.graphIndexStatement" id="apidoc.element.jscodeshift.types.builders.graphIndexStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>graphIndexStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphIndexStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.graphStatement" id="apidoc.element.jscodeshift.types.builders.graphStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>graphStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.identifier" id="apidoc.element.jscodeshift.types.builders.identifier">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>identifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
For example, the following creates an AST equivalent to `foo(bar)`:

```js
// inside a module transform
var j = jscodeshift;
// foo(bar);
var ast = j.callExpression(
  j.<span class="apidocCodeKeywordSpan">identifier</span>('foo'),
  [j.identifier('bar')]
);
```

The signature of each builder function is best learned by having a look at the
[definition files](https://github.com/benjamn/ast-types/blob/master/def/).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.identifierStatement" id="apidoc.element.jscodeshift.types.builders.identifierStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>identifierStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identifierStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.ifStatement" id="apidoc.element.jscodeshift.types.builders.ifStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>ifStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ifStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.import" id="apidoc.element.jscodeshift.types.builders.import">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>import
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.importDeclaration" id="apidoc.element.jscodeshift.types.builders.importDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>importDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.importDefaultSpecifier" id="apidoc.element.jscodeshift.types.builders.importDefaultSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>importDefaultSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importDefaultSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.importNamespaceSpecifier" id="apidoc.element.jscodeshift.types.builders.importNamespaceSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>importNamespaceSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importNamespaceSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.importSpecifier" id="apidoc.element.jscodeshift.types.builders.importSpecifier">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>importSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.importStatement" id="apidoc.element.jscodeshift.types.builders.importStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>importStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.interfaceDeclaration" id="apidoc.element.jscodeshift.types.builders.interfaceDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>interfaceDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interfaceDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.interfaceExtends" id="apidoc.element.jscodeshift.types.builders.interfaceExtends">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>interfaceExtends
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interfaceExtends = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.intersectionTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.intersectionTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>intersectionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersectionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxAttribute" id="apidoc.element.jscodeshift.types.builders.jsxAttribute">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxAttribute = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxClosingElement" id="apidoc.element.jscodeshift.types.builders.jsxClosingElement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxClosingElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxClosingElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxElement" id="apidoc.element.jscodeshift.types.builders.jsxElement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxElementStatement" id="apidoc.element.jscodeshift.types.builders.jsxElementStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxElementStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxElementStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxEmptyExpression" id="apidoc.element.jscodeshift.types.builders.jsxEmptyExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxEmptyExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxEmptyExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxEmptyStatement" id="apidoc.element.jscodeshift.types.builders.jsxEmptyStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxEmptyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxEmptyStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxExpressionContainer" id="apidoc.element.jscodeshift.types.builders.jsxExpressionContainer">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxExpressionContainer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxExpressionContainer = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxExpressionContainerStatement" id="apidoc.element.jscodeshift.types.builders.jsxExpressionContainerStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxExpressionContainerStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxExpressionContainerStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxIdentifier" id="apidoc.element.jscodeshift.types.builders.jsxIdentifier">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxIdentifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxIdentifierStatement" id="apidoc.element.jscodeshift.types.builders.jsxIdentifierStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxIdentifierStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxIdentifierStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxMemberExpression" id="apidoc.element.jscodeshift.types.builders.jsxMemberExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxMemberExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxMemberExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxMemberStatement" id="apidoc.element.jscodeshift.types.builders.jsxMemberStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxMemberStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxMemberStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxNamespacedName" id="apidoc.element.jscodeshift.types.builders.jsxNamespacedName">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxNamespacedName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxNamespacedName = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxOpeningElement" id="apidoc.element.jscodeshift.types.builders.jsxOpeningElement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxOpeningElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxOpeningElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxSpreadAttribute" id="apidoc.element.jscodeshift.types.builders.jsxSpreadAttribute">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxSpreadAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxSpreadAttribute = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxText" id="apidoc.element.jscodeshift.types.builders.jsxText">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxText = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.jsxTextStatement" id="apidoc.element.jscodeshift.types.builders.jsxTextStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>jsxTextStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxTextStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.labeledStatement" id="apidoc.element.jscodeshift.types.builders.labeledStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>labeledStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">labeledStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.letExpression" id="apidoc.element.jscodeshift.types.builders.letExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>letExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">letExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.letStatement" id="apidoc.element.jscodeshift.types.builders.letStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>letStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">letStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.line" id="apidoc.element.jscodeshift.types.builders.line">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">line = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.literal" id="apidoc.element.jscodeshift.types.builders.literal">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>literal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">literal = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.literalStatement" id="apidoc.element.jscodeshift.types.builders.literalStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>literalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">literalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.logicalExpression" id="apidoc.element.jscodeshift.types.builders.logicalExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>logicalExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logicalExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.logicalStatement" id="apidoc.element.jscodeshift.types.builders.logicalStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>logicalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logicalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.memberExpression" id="apidoc.element.jscodeshift.types.builders.memberExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>memberExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.memberStatement" id="apidoc.element.jscodeshift.types.builders.memberStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>memberStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.memberTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.memberTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>memberTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.metaProperty" id="apidoc.element.jscodeshift.types.builders.metaProperty">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>metaProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">metaProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.metaPropertyStatement" id="apidoc.element.jscodeshift.types.builders.metaPropertyStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>metaPropertyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">metaPropertyStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.methodDefinition" id="apidoc.element.jscodeshift.types.builders.methodDefinition">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>methodDefinition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">methodDefinition = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.mixedTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.mixedTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>mixedTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixedTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.newExpression" id="apidoc.element.jscodeshift.types.builders.newExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>newExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.newStatement" id="apidoc.element.jscodeshift.types.builders.newStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>newStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.noop" id="apidoc.element.jscodeshift.types.builders.noop">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>noop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noop = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.nullLiteral" id="apidoc.element.jscodeshift.types.builders.nullLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>nullLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.nullLiteralStatement" id="apidoc.element.jscodeshift.types.builders.nullLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>nullLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.nullLiteralTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.nullLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>nullLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.nullTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.nullTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>nullTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.nullableTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.nullableTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>nullableTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullableTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.numberLiteralTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.numberLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>numberLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.numberTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.numberTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>numberTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.numericLiteral" id="apidoc.element.jscodeshift.types.builders.numericLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>numericLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.numericLiteralStatement" id="apidoc.element.jscodeshift.types.builders.numericLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>numericLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.numericLiteralTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.numericLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>numericLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.objectExpression" id="apidoc.element.jscodeshift.types.builders.objectExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.objectMethod" id="apidoc.element.jscodeshift.types.builders.objectMethod">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectMethod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectMethod = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.objectPattern" id="apidoc.element.jscodeshift.types.builders.objectPattern">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.objectProperty" id="apidoc.element.jscodeshift.types.builders.objectProperty">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.objectStatement" id="apidoc.element.jscodeshift.types.builders.objectStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.objectTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.objectTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.objectTypeCallProperty" id="apidoc.element.jscodeshift.types.builders.objectTypeCallProperty">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectTypeCallProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeCallProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.objectTypeIndexer" id="apidoc.element.jscodeshift.types.builders.objectTypeIndexer">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectTypeIndexer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeIndexer = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.objectTypeProperty" id="apidoc.element.jscodeshift.types.builders.objectTypeProperty">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>objectTypeProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.parenthesizedExpression" id="apidoc.element.jscodeshift.types.builders.parenthesizedExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>parenthesizedExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parenthesizedExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.parenthesizedStatement" id="apidoc.element.jscodeshift.types.builders.parenthesizedStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>parenthesizedStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parenthesizedStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.position" id="apidoc.element.jscodeshift.types.builders.position">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>position
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">position = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.program" id="apidoc.element.jscodeshift.types.builders.program">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>program
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">program = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.property" id="apidoc.element.jscodeshift.types.builders.property">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>property
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.propertyPattern" id="apidoc.element.jscodeshift.types.builders.propertyPattern">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>propertyPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">propertyPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.qualifiedTypeIdentifier" id="apidoc.element.jscodeshift.types.builders.qualifiedTypeIdentifier">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>qualifiedTypeIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">qualifiedTypeIdentifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.regExpLiteral" id="apidoc.element.jscodeshift.types.builders.regExpLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>regExpLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regExpLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.regExpLiteralStatement" id="apidoc.element.jscodeshift.types.builders.regExpLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>regExpLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regExpLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.restElement" id="apidoc.element.jscodeshift.types.builders.restElement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>restElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.restProperty" id="apidoc.element.jscodeshift.types.builders.restProperty">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>restProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.returnStatement" id="apidoc.element.jscodeshift.types.builders.returnStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>returnStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">returnStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.sequenceExpression" id="apidoc.element.jscodeshift.types.builders.sequenceExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>sequenceExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequenceExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.sequenceStatement" id="apidoc.element.jscodeshift.types.builders.sequenceStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>sequenceStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequenceStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.sourceLocation" id="apidoc.element.jscodeshift.types.builders.sourceLocation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>sourceLocation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sourceLocation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.spreadElement" id="apidoc.element.jscodeshift.types.builders.spreadElement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>spreadElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.spreadElementPattern" id="apidoc.element.jscodeshift.types.builders.spreadElementPattern">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>spreadElementPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadElementPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.spreadProperty" id="apidoc.element.jscodeshift.types.builders.spreadProperty">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>spreadProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.spreadPropertyPattern" id="apidoc.element.jscodeshift.types.builders.spreadPropertyPattern">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>spreadPropertyPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadPropertyPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.stringLiteral" id="apidoc.element.jscodeshift.types.builders.stringLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>stringLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.stringLiteralStatement" id="apidoc.element.jscodeshift.types.builders.stringLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>stringLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.stringLiteralTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.stringLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>stringLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.stringTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.stringTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>stringTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.super" id="apidoc.element.jscodeshift.types.builders.super">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.superStatement" id="apidoc.element.jscodeshift.types.builders.superStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>superStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.switchCase" id="apidoc.element.jscodeshift.types.builders.switchCase">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>switchCase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchCase = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.switchStatement" id="apidoc.element.jscodeshift.types.builders.switchStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>switchStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.taggedTemplateExpression" id="apidoc.element.jscodeshift.types.builders.taggedTemplateExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>taggedTemplateExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">taggedTemplateExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.taggedTemplateStatement" id="apidoc.element.jscodeshift.types.builders.taggedTemplateStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>taggedTemplateStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">taggedTemplateStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.templateElement" id="apidoc.element.jscodeshift.types.builders.templateElement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>templateElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.templateLiteral" id="apidoc.element.jscodeshift.types.builders.templateLiteral">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>templateLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.templateLiteralStatement" id="apidoc.element.jscodeshift.types.builders.templateLiteralStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>templateLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.thisExpression" id="apidoc.element.jscodeshift.types.builders.thisExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>thisExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.thisStatement" id="apidoc.element.jscodeshift.types.builders.thisStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>thisStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.thisTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.thisTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>thisTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.throwStatement" id="apidoc.element.jscodeshift.types.builders.throwStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>throwStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.tryStatement" id="apidoc.element.jscodeshift.types.builders.tryStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>tryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.tupleTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.tupleTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>tupleTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tupleTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.typeAlias" id="apidoc.element.jscodeshift.types.builders.typeAlias">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeAlias
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeAlias = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.typeAnnotation" id="apidoc.element.jscodeshift.types.builders.typeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.typeCastExpression" id="apidoc.element.jscodeshift.types.builders.typeCastExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeCastExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeCastExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.typeCastStatement" id="apidoc.element.jscodeshift.types.builders.typeCastStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeCastStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeCastStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.typeParameter" id="apidoc.element.jscodeshift.types.builders.typeParameter">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeParameter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameter = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.typeParameterDeclaration" id="apidoc.element.jscodeshift.types.builders.typeParameterDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeParameterDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameterDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.typeParameterInstantiation" id="apidoc.element.jscodeshift.types.builders.typeParameterInstantiation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeParameterInstantiation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameterInstantiation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.typeofTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.typeofTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>typeofTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeofTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.unaryExpression" id="apidoc.element.jscodeshift.types.builders.unaryExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>unaryExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unaryExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.unaryStatement" id="apidoc.element.jscodeshift.types.builders.unaryStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>unaryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unaryStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.unionTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.unionTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>unionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.updateExpression" id="apidoc.element.jscodeshift.types.builders.updateExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>updateExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.updateStatement" id="apidoc.element.jscodeshift.types.builders.updateStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>updateStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.variableDeclaration" id="apidoc.element.jscodeshift.types.builders.variableDeclaration">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>variableDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">variableDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.variableDeclarator" id="apidoc.element.jscodeshift.types.builders.variableDeclarator">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>variableDeclarator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">variableDeclarator = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.voidTypeAnnotation" id="apidoc.element.jscodeshift.types.builders.voidTypeAnnotation">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>voidTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">voidTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.whileStatement" id="apidoc.element.jscodeshift.types.builders.whileStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>whileStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whileStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.withStatement" id="apidoc.element.jscodeshift.types.builders.withStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>withStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.yieldExpression" id="apidoc.element.jscodeshift.types.builders.yieldExpression">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>yieldExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yieldExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          "attempting to instantiate unfinalized type " +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error("" + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &amp;&amp; i &lt; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = "no value or default function given for field " +
              JSON.stringify(param) + " of " + self.typeName + "(" +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(", ") + ")";
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              " does not match field " + field +
              " of type " + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the "type" field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error("");
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscodeshift.types.builders.yieldStatement" id="apidoc.element.jscodeshift.types.builders.yieldStatement">
        function <span class="apidocSignatureSpan">jscodeshift.types.builders.</span>yieldStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yieldStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>